/*************************************************************************
// Copyright IBM Corp. 2023
//
// Licensed under the Apache License 2.0 (the "License").  You may not use
// this file except in compliance with the License.  You can obtain a copy
// in the file LICENSE in the source distribution.
*************************************************************************/

/*************************************************************************
// Description: Source for the icclib shared library                         
//
*************************************************************************/

#if defined(__MVS__)
/* Exported symbol definitions for z/OS - generated by ICCencapsulator.java
   z/OS handles exported symbol visibility - differently -
*/
#include "exports/icclib_zos.h"
#endif
/* Needs to be here to pick up macros to enable Dl_info etc */
#include "loaded.h" 
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>


#include "iccversion.h"
#include "platform.h"
#include "iccglobals.h"
#include "fips.h"
#include "fips-prng/fips-prng-RAND.h"
#include "platfsl.h"
#include "iccerr.h"
#include "TRNG/entropy_estimator.h"
#include "TRNG/ICC_NRBG.h"
#include "openssl/opensslv.h"
#include "crypto/evp.h"
#include "openssl/evp.h"

#if(OPENSSL_VERSION_NUMBER < 0x1010105fL)
#   include "crypto/rsa/rsa_locl.h"
# include "crypto/dsa/dsa_locl.h"
#else
#   include "crypto/rsa/rsa_local.h"
# include  "crypto/dsa/dsa_local.h"
#endif
#define ICCLIB 1
#include "icc_a.h"
#undef ICCLIB
#include "icc_common.h"

#if defined(STANDALONE_ICCLIB)
#include "DELTA/delta_t.h"
#include "DELTA/delta.c"

unsigned long d[10];
#endif

/* If this is set, the support code for tracing is inserted here 
   IFF tracing is enabled.
*/
#define TRACE_CODE 1

#include "tracer.h"

#if defined(_WIN32)
#   define strdup(x) _strdup(x)
#endif

extern int ex_loops,ex_shift;

extern int Shift();
extern unsigned int Loops();
extern int isFipsTrng(TRNG_TYPE t);

/* Prototype for the FIPS compliant keygen function */

int fips_rsa_builtin_keygen(RSA *rsa, int bits,int primes, BIGNUM *e_value,BN_GENCB *cb);
/* Forward declarations for redirected functions 
  Note that in all these interfaces pcb is non-NULL just to get here
*/

DH * my_DH_generate_parameters(ICClib *pcb,int bits, int generator,void (*callback)(int,int,void *),void *cb_arg);
RSA *  my_RSA_generate_key(ICClib *pcb,int bits, unsigned long e,void (*callback)(int,int,void *),void *cb_arg);
int my_RSA_generate_key_ex(ICClib *pcb,RSA *rsa, int bits, BIGNUM *e,void *callback);
DSA *my_DSA_generate_parameters(ICClib *pcb,int bits,unsigned char *seed,int seed_len,int *counter_ret, unsigned long *h_ret,void (*callback)(int, int, void *),void *cb_arg);
int my_DSA_generate_key(ICClib *pcb,DSA *a);
EC_KEY *my_EC_KEY_new_by_curve_name(ICClib *pcb,int nid);
int my_EC_KEY_generate_key(ICClib *pcb,EC_KEY *eckey);
PRNG * my_get_RNGbyname(ICClib *pcb,const char *algname);
int my_EVP_DigestInit(EVP_MD_CTX *ctx,const EVP_MD *md);
int my_EVP_DigestFinal(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *size);

int my_RAND_bytes(unsigned char *buf,int n);
int my_EVP_PKEY_encrypt_new(EVP_PKEY_CTX *ctx, 
			    unsigned char *out, size_t *outlen,
			    const unsigned char *in, size_t inlen);
int my_EVP_PKEY_decrypt_new(EVP_PKEY_CTX *ctx, 
			    unsigned char *out, size_t *outlen,
			    const unsigned char *in, size_t inlen);
int my_EVP_PKEY_keygen(ICClib *pcb, EVP_PKEY_CTX *cctx, EVP_PKEY **pk);
int my_EVP_CIPHER_CTX_free(EVP_CIPHER_CTX * x);
int my_EVP_DigestSignInit(ICClib *pcb,EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);
int my_EVP_DigestVerifyInit(ICClib *pcb,EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);
int my_SP800_38F_KW(ICClib *pcb,unsigned char *in, int inl, unsigned char *out, int *outl, unsigned char *key, int kl,unsigned int flags) ;
int my_EVP_PKEY_sign_init(ICClib *pcb,EVP_PKEY_CTX *pctx);
int my_EVP_PKEY_verify_init(ICClib *pcb,EVP_PKEY_CTX *pctx);
void my_GHASH(AES_GCM_CTX *gcm_ctx,unsigned char *H,unsigned char *Hash,unsigned char *data,unsigned long datalen);
int my_EVP_PKEY_derive_init(ICClib *pcb,EVP_PKEY_CTX *ctx);
int my_RSA_sign(ICClib *pcb,int type, const unsigned char *dgst, int dlen, unsigned char *sig, unsigned int *siglen, RSA *rsa);
int my_RSA_verify(ICClib *pcb,int type, const unsigned char *dgst, int dgst_len, const unsigned char *sigbuf, int siglen, RSA *rsa);
int my_DH_generate_key(ICClib *pcb,DH *dh);
int my_RSA_private_decrypt(ICClib *pcb,int flen, const unsigned char *from,unsigned char *to, RSA *rsa,int padding);
int my_RSA_public_encrypt(ICClib *pcb,int flen, unsigned char *from,unsigned char *to, RSA *rsa,int padding);
int my_RSA_private_encrypt(ICClib *pcb,int flen, const unsigned char *from,unsigned char *to, RSA *rsa,int padding);
int my_RSA_public_decrypt(ICClib *pcb,int flen, unsigned char *from,unsigned char *to, RSA *rsa,int padding);
int my_DH_compute_key(ICClib *pcb,unsigned char *key,BIGNUM *pub_key,DH *dh);
int my_DH_compute_key_padded(ICClib *pcb,unsigned char *key,BIGNUM *pub_key,DH *dh);
int my_PKCS5_PBKDF2_HMAC(ICClib *pcb,const char *pass, int passlen, const unsigned char *salt, int saltlen, int iters, const EVP_MD *digest, int keylen, unsigned char *out);
unsigned char *HKDF_Extract(ICClib *pcb,const EVP_MD *evp_md,const unsigned char *salt, size_t salt_len,const unsigned char *key, size_t key_len,unsigned char *prk, size_t *prk_len);
unsigned char *HKDF_Expand(ICClib *pcb,const EVP_MD *evp_md,const unsigned char *prk, size_t prk_len,const unsigned char *info, size_t info_len,unsigned char *okm, size_t okm_len);
unsigned char *HKDF(ICClib *pcb,const EVP_MD *evp_md,const unsigned char *salt, size_t salt_len,const unsigned char *key, size_t key_len,const unsigned char *info, size_t info_len,unsigned char *okm, size_t okm_len);
int dsa_paramgen_check_g(DSA *dsa);

/* From extsig.c */
int CheckSig(FILE *fin,FILE *targ,EVP_PKEY *rsaPKey,int SigFileOnly);
int ReadConfigItems(FILE *fin, char *tweaks[], int n);
/* from fips.c */
EVP_PKEY *get_pubkey(ICC_STATUS *stat);
extern int iccRSAKeyPair(ICClib *pcb, RSA *temp);

const BIGNUM *DH_get_PrivateKey (const DH * dh);
extern int TwoKeyDes3(int);
/* API to tell OpenSSL it's in FIPS mode
   Use to conditionally disable some (expensive) tests
   when in FIPS mode
*/
extern int FIPS_mode_set(int);
/* Macrod to other functions, which doesn't work 
   well if they are entries in a call table.
   Provide these as wrappers instead
*/

#undef EVP_MD_CTX_init
#undef EVP_MD_CTX_cleanup
#undef EVP_CIPHER_CTX_init
#undef EVP_CIPHER_CTX_cleanup
#undef EVP_CIPHER_CTX_flags

int EVP_MD_CTX_init(EVP_MD_CTX *ctx);
int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);
int EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_flags(EVP_CIPHER_CTX *ctx);

int RSA_FixEncodingZeros(RSA* pri, const RSA* pub, int allowDisableBlinding);
int InternalIntegrityCheck(ICClib *pcb,ICC_STATUS *status,int partial);
int IntegrityCheck(ICClib *pcb,ICC_STATUS *status);

void ALT_Final(); /* Clean up the fd used for /dev/random */
/*
 *-----------------------------------------------------------------------------
 * INCLUDED source. 
 *-----------------------------------------------------------------------------
 */
/* Drop in code for digsetbyname,cipherbyname */
#include "nid_cache.c"

/* Include the function table */
#include "icclib_a.c"


/* If not NULL we'll attempt to print the first fatal error to this destination
 */
FILE *errorfile = NULL;

/* The call table between ICC_Init() and ICC_Attach(), no crypto function */
static FUNC ICCGlobal_Partial[NUM_ICCLIBFUNCTIONS];
/* The call table if an error is hit, actually copied over the normal 
   running table if it's a critical error. No new objects can be created
*/
static FUNC ICCGlobal_Error[NUM_ICCLIBFUNCTIONS];


static int fips_lie = 0; /*!< If set ICC will lie about it's FIPS state if requested */
#if (NON_FIPS_ICC == 1)
static int config_run_post = 0; /*!< Only an option in non-FIPS ICC's */
#else
static int config_run_post = 1;
#endif
static char *exclude_list = NULL; /*!< List of excluded RNG modes */
static int trng_set = 0; /*!< Some clever for TRNG handling in testing */
const char ICC_SCCSInfo[] =
{
    "@(#)CompanyName:      IBM Corporation\n"
    "@(#)LegalTrademarks:  IBM\n"
    "@(#)FileDescription:  " ICC_DESCRIPTION1 ICC_DESCRIPTION2 "\n"
    "@(#)FileVersion:      " ICC_PRODUCT_VERSION "\n"
    "@(#)LegalCopyright:   Licensed Materials - Property of IBM\n"
    "@(#)                  ICC\n"
    "@(#)                  (C) Copyright IBM Corp. 2002,2015\n"
    "@(#)                  All Rights Reserved. US Government Users\n"
    "@(#)                  Restricted Rights - Use, duplication or disclosure\n"
    "@(#)                  restricted by GSA ADP Schedule Contract with IBM Corp.\n"
    "@(#)ProductName:      " ICC_PRODUCT_NAME "\n"
    "@(#)ProductVersion:   " ICC_PRODUCT_VERSION "\n"
    "@(#)ProductInfo:      " ICC_PRODUCT_INFO "\n"
    "@(#)CMVCInfo:         " ICC_CMVC_INFO "\n"
};



char tmp; /* Used solely to force the linker to include SCCSInfo */ 






/*
 *-----------------------------------------------------------------------------
 * typedefs
 *-----------------------------------------------------------------------------
 */


/*! @brief prototype for a pointer to an OpenSSL locking function */
typedef void (*LockFunc) (int, int, const char *, int);

/*! @brief prototype for a pointer to a function to return a unqiue thread ID */
typedef unsigned long (*ThreadIdFunc) (void);

void *ICC_Malloc(size_t sz, const char *file, int line);
void *ICC_Calloc(size_t n, size_t sz,const char *file, int line);
void *ICC_Realloc(void *ptr,size_t sz,const char *file, int line);
void ICC_Free(void *ptr);
void CleanupSP800_90(void);


static char *no_excluded_rngs = "";


/*
 *-----------------------------------------------------------------------------
 * globals
 *-----------------------------------------------------------------------------
 */


static int FIPS_init_flag = 0;		


extern char * FIPS_ERROR;



static RSA_METHOD * FIPS_RSA_meth = NULL; /*!< The FIPS RSA method, uses X9.31 key gen */

/*! @brief Triggers induced failure tests if !0, 
  set programatically via 
  ICC_Set_Value(ctx,status,ICC_INDUCED_FAILURE,(void *)somevalue) 
  Being called before ICC_Init()
*/
unsigned int icc_failure = 0;

/*! @brief disallows 'late' setting of ICC_INDUCED_FAILURE */
static unsigned int icc_failure_mask = 0;

/*! @brief - simply a dummy so that ICC_GetValue() works
  This is acted on in the ICC static stub.
*/
unsigned int clean_at_exit = 0;


static void OpenSSL_Init(ICClib *pcb,ICC_STATUS * status);
static void OpenSSL_Cleanup();


/*
  Load/unload  additional error strings into OpenSSL
  (errors caused by OpenSSL calling down into ICC
*/
static void iccLoadErr(ICC_STATUS* status);

void OPENSSL_cpuid_setup(void);


/* Legacy, from when these could be set at startup */

void *ICC_Malloc(size_t sz, const char *file, int line)
{
  void *ptr = NULL;
  ptr = CRYPTO_malloc(sz,file,line);
  return ptr;
}


void *ICC_Calloc(size_t n, size_t sz,const char *file, int line)
{
  void *ptr = NULL;

  ptr = CRYPTO_calloc(n,sz,file,line);


  return ptr;
}

void *ICC_Realloc(void *ptr,size_t sz,const char *file, int line)
{
  void *iptr = NULL;

  iptr = CRYPTO_realloc(ptr,sz,file,line);
  return iptr;
}

void ICC_Free(void *ptr)
{
    CRYPTO_free(ptr,__FILE__,__LINE__);       
}
static unsigned char x2bin(unsigned char b)
{
  unsigned char c = 0;
  if( b >= '0' && b <= '9') {
    c = (b - '0');
  } else if (b >= 'a' && b <= 'f') {
    c = (b - 'a') + 10;
  }  else if (b >= 'A' && b <= 'F') {
    c = (b - 'F') + 10;
  }    
  return c;

}
/* Called from the status code when a fatal error is tripped */
void DisableAPI(void) 
{
   memcpy(ICCGlobal_default, ICCGlobal_Error, sizeof(ICCGlobal_default));
}
/* The actual FIPS and ERROR flags are stored inside the opaque PCB object,
   and the ICC_STATUS is user provided.
   So we need to set these on exit to ensure the copy in the user supplied status
   is accurate. Note that pcb may be NULL on some of these paths.
*/
ICCSTATIC void SetFlags(ICClib *pcb, ICC_STATUS *status) {
  if (NULL != pcb) {
    status->mode = pcb->flags;
  }
}
static int set_cap(const char *cptr, unsigned long long *cap)
{
  int i = 0;
  unsigned long long v = 0;
  unsigned char c = '\0';
  int temp = ICC_OK;

  for(i = 0; i < 16; i+= 2) {
    v = v * 256;
    if('\0' == cptr[i]) {
      break;
    }
    if(!isxdigit(cptr[i]) || !isxdigit(cptr[i+1]) ) {
        temp = ICC_WARNING;
      break;
    }
    c = x2bin((unsigned char)cptr[i]);
    v |= (c << 4) | x2bin((unsigned char)cptr[i+1]);
    
  }
  if('\0' == cptr[i]) {
    *cap = v;
  } else {
    temp = ICC_WARNING;
  }
  return temp;
}
static void EnvVars()
{
  unsigned long long cap = (unsigned long long)(-1LL);
  const char *tmp = NULL;
  int i = 0;
  char *lie_about_FIPS = NULL;

  IN();

  /*! \EnvVar ICC_IGNORE_FIPS 
    - Force development versions of ICC to accept FIPS mode
    ICC variants that were never certification candidates.
    - Usage: export ICC_INGORE_FIPS=yes
    - Platforms: All
    - Uses: The certification status of ICC can be determined from 
    version number, platform and the ICC Security policy but it may 
    be hard to determine  which version of ICC is  in use if 
    multiple instances exist on one machine.
    - The logic is:
    If ICC_IGNORE_FIPS is set, and not obviously No or False, we assume it means "yes"
    - 
    - FIPS: The module is not in FIPS mode if this enviroment variable 
    is set. This mode is for test purposes.
  */
  /* In a known FIPS release, we insist on a manual override 
     before we'll allow the module to exit FIPS mode.
  */
  fips_lie = 0;
  lie_about_FIPS = getenv ("ICC_IGNORE_FIPS");
  if ((lie_about_FIPS != NULL) &&
      (lie_about_FIPS[0] != 'N') &&
      (lie_about_FIPS[0] != 'n') &&
      (lie_about_FIPS[0] != 'F') && 
      (lie_about_FIPS[0] != 'f') &&
      (lie_about_FIPS[0] != '0')
      ) {
     MARK("ICC_IGNORE_FIPS", tmp);
     fips_lie = 1;
  }
  /*! \EnvVar ICC_INDUCED_FAILURE
    - Allows error paths to be tested programatically
    - FIPS mode: No
   */
  tmp = getenv("ICC_INDUCED_FAILURE");
  if(NULL != tmp) {
     MARK("ICC_INDUCED_FAILURE", tmp);
     icc_failure = atoi(tmp);
  }
  /*! \EnvVar ICC_ALLOW_INDUCED
    - Allows error paths to be tested programatically after startup
    - FIPS mode: No
   */
  
  tmp = getenv("ICC_ALLOW_INDUCED");
  if(NULL != tmp) {
     MARK("ICC_ALLOW_INDUCED", tmp);
     icc_failure_mask = atoi(tmp);
  }
#if (NON_FIPS_ICC == 1)  
  /*! \EnvVar ICC_RUN_POST
    - Turns full POST on in non-FIPS mode
    - FIPS mode: No
   */
  tmp = getenv("ICC_RUN_POST");
  if(NULL != tmp) {
     MARK("ICC_RUN_POST", tmp);
     config_run_post = atoi(tmp);
  }
#endif
  /*! \EnvVar ICC_RNG_TUNER
    - Allows error paths to be tested programatically after startup
    - FIPS mode: No
   */


  tmp = getenv("ICC_RNG_TUNER");
  if(NULL != tmp) {
    MARK("ICC_RNG_TUNER", tmp);
    i = atoi(tmp);
    Set_default_tuner(i);
  }
  /*! \EnvVar ICC_RNG_INSTANCES
    - Sets the number of RNG's in the thread pool. Used to improve scaling
      on really large systems.
    - FIPS mode: Yes
   */

  tmp = getenv("ICC_RNG_INSTANCES");
  if(NULL != tmp) {
    MARK("ICC_RNG_INSTANCES", tmp);
    i = atoi(tmp);
    SetRNGInstances(i);
  }
  /*! \EnvVar ICC_TRNG
    - Sets the type of the TRNG used by default.
   */

  
  tmp = getenv("ICC_TRNG");
  if(NULL != tmp) {
    MARK("ICC_TRNG", tmp);
    SetTRNGName((char *)tmp);
    trng_set = 1;
  }
  /*! \EnvVar ICC_RANDOM_GENERATOR
    - Sets the type of the PRNG used by default.
    - TRNG, the default timer based entropy source on most platforms.
    - Must be FIPS approved and 256 bit effective strength
    - FIPS mode: Yes
   */
  
  tmp = getenv("ICC_RANDOM_GENERATOR");
  if(NULL != tmp) {
     MARK("ICC_RANDOM_GENERATOR", tmp);
     SetPRNGName((char *)tmp);
  }
  /*! \EnvVar ICC_CAP_MASK
    - Disables hardware features used for acceleration
    - FIPS mode: Default or 0000000000000000 (all acceleration off) are allowed
   */
  
  tmp = getenv("ICC_CAP_MASK");
  if(NULL != tmp && (16 == strlen(tmp))) {
    if(ICC_OK == set_cap(tmp,&cap)) {
      MARK("OPENSSL_cpuid_override()","");
      OPENSSL_cpuid_override(cap);
    }
  }
  /*! \EnvVar ICC_RNG_SETUP
    - Forces full RNG setup in all TRNG modes
    - FIPS mode: Yes
  */
  tmp = getenv("ICC_RNG_SETUP");
  if(NULL != tmp) {
    MARK("ICC_RNG_SETUP", tmp);
    i = atoi(tmp);
    Set_rng_setup(i);
  }
  /*! \EnvVar ICC_SHIFT
    - Manual setting of RNG modes
    - May be required to bypass problems on virtualized systems/new hardware
    - FIPS mode: Yes
    - Use only under direction from GSkit L3
  */

  tmp = getenv("ICC_SHIFT");
  if(NULL != tmp) {
    MARK("ICC_SHIFT", tmp);
    i = atoi(tmp);
    ex_shift = i;
  }
  /*! \EnvVar ICC_LOOPS
    - Manual setting of RNG modes
    - May be required to bypass problems on virtualized systems/new hardware
    - FIPS mode: Yes
    - Use only under direction from GSkit L3
  */

  tmp = getenv("ICC_LOOPS");
  if(NULL != tmp) {
    MARK("ICC_LOOPS", tmp);
    i = atoi(tmp);
    ex_loops = i;
  }
  /*! \EnvVar ICC_ALLOW_2KEY3DES
    - Allows 3 DES with 2 keys the same
    - FIPS mode: No
    - Required to pass NIST 3DES tests
  */

  TwoKeyDes3(1);
  tmp = getenv("ICC_ALLOW_2KEY3DES");
  if(NULL != tmp) {
    MARK("ICC_ALLOW_2KEY3DES", tmp);
    i = atoi(tmp);
    TwoKeyDes3(i);
  }

  /*! \EnvVar ICC_RNG_EXCLUDED
    - Sets a black list of RNG modes
    - Disables modes known to have flaws
    - FIPS mode: Yes
  */
  
  tmp = getenv("ICC_RNG_EXCLUDED");
  if(NULL != tmp) {
    MARK("ICC_RNG_EXCLUDED", tmp);
    if(NULL != exclude_list) {
      free(exclude_list);
    }
    exclude_list = strdup(tmp);
    Set_rng_exclude(exclude_list); /* Requires a persistant string */
  }
  /*! \EnvVar ICC_FATAL
       Log fatal errors to stdout/stderr 
       Note that if trace is enabled these will always go to trace
     - FIPS mode: Yes
   */

  tmp = getenv("ICC_FATAL");
  if (NULL != tmp) {
    MARK("ICC_FATAL", tmp);
    if(0 == strcmp(tmp,"stdout")) {
        errorfile = stdout;
    } else if(0 == strcmp(tmp,"stderr")) {
      errorfile = stderr;
    }
  }

  OUT();
}

void SetParams(char *params[],int n)
{
  int i ;
  unsigned long long cap = (unsigned long long)(-1LL);
  char *ptr = NULL;
  IN();
  for (i = 0; i < n; i++) {
    if (NULL == params[i]) {
      break;
    } else {
      ptr = strchr(params[i], '=');
      if (NULL != ptr) {
        ptr++;
        if (0 == strncmp(params[i], "ICC_INDUCED_FAILURE",
                         strlen("ICC_INDUCED_FAILURE"))) {
          MARK("ICC_INDUCED_FAILURE", ptr);
          icc_failure = atoi(ptr);
        }

        if (0 == strncmp(params[i], "ICC_ALLOW_INDUCED",
                         strlen("ICC_ALLOW_INDUCED"))) {
          MARK("ICC_ALLOW_INDUCED", ptr);
          icc_failure_mask = atoi(ptr);
        }

        if (0 == strncmp(params[i], "ICC_RNG_TUNER", strlen("ICC_RNG_TUNER"))) {
          MARK("ICC_RNG_TUNER", ptr);
          Set_default_tuner(atoi(ptr));
        }
        if (0 == strncmp(params[i], "ICC_SHIFT", strlen("ICC_SHIFT"))) {
          MARK("ICC_SHIFT", ptr);
          ex_shift = atoi(ptr);
        }

        if (0 == strncmp(params[i], "ICC_LOOPS", strlen("ICC_LOOPS"))) {
          MARK("ICC_LOOPS", ptr);
          ex_loops = atoi(ptr);
        }
#if (NON_FIPS_ICC == 1)
        if (0 == strncmp(params[i], "ICC_RUN_POST", strlen("ICC_RUN_POST"))) {
          MARK("ICC_RUN_POST", ptr);
          config_run_post = atoi(ptr);
        }
#endif

        if (0 == strncmp(params[i], "ICC_ALLOW_2KEY3DES",
                         strlen("ICC_ALLOW_2KEY3DES"))) {
          MARK("ICC_ALLOW_2KEY3DES", ptr);
          TwoKeyDes3(atoi(ptr));
        }

        if (0 == strncmp(params[i], "ICC_RNG_INSTANCES",
                         strlen("ICC_RNG_INSTANCES"))) {
          MARK("ICC_RNG_INSTANCES", ptr);
          SetRNGInstances(atoi(ptr));
        }

        if (0 == strncmp(params[i], "ICC_TRNG", strlen("ICC_TRNG"))) {
          MARK("ICC_TRNG", ptr);
          SetTRNGName(ptr);
          trng_set = 1;
        }

        if (0 == strncmp(params[i], "ICC_RANDOM_GENERATOR",
                         strlen("ICC_RANDOM_GENERATOR"))) {
           MARK("ICC_RANDOM_GENERATOR", ptr);
           SetPRNGName(ptr);
        }

        if (0 == strncmp(params[i], "ICC_CAP_MASK", strlen("ICC_CAP_MASK"))) {
          if (16 == strlen(ptr)) {
            if (ICC_OK == set_cap(ptr, &cap)) {
              MARK("OPENSSL_cpuid_override()", "");
              OPENSSL_cpuid_override(cap);
            }
          }
        }
        if (0 == strncmp(params[i], "ICC_RNG_SETUP", strlen("ICC_RNG_SETUP"))) {
           MARK("ICC_RNG_SETUP", ptr);
           Set_rng_setup(atoi(ptr));
        }

        if (0 == strncmp(params[i], "ICC_RNG_EXCLUDED", strlen("ICC_RNG_EXCLUDED"))) {
          MARK("ICC_RNG_EXCLUDED", ptr);
          if (NULL != exclude_list) {
            free(exclude_list);
          }
          exclude_list = strdup(ptr);
          Set_rng_exclude(exclude_list);
        }
        if(0 == strncmp(params[i],"ICC_FATAL",strlen("ICC_FATAL"))) {
          MARK("ICC_FATAL", ptr);
          if (0 == strcmp(ptr, "stdout")) {
            errorfile = stdout;
          } else if(0 == strcmp(ptr,"stderr")) {
            errorfile = stderr;
          }
        }
      }
      free(params[i]);
      params[i] = NULL;
    }
  }
  OUT();
}

/* Set up the call tables that will be used by the static stub to access
   crypto. function
*/
static void LoadTable(ICC_STATUS *status)
{
  int i = 0, j= 0;
  IN(); 
  /* NUM_ICCLIBFUNCTIONS -1 because of the NULL,NULL terminal entry */
  for(i = j = 0; (i < (NUM_ICCLIBFUNCTIONS-1)) && (NULL != Global.funcs[i].name) ; i++, j++) {
    /* We sometimes need to redirect functions, so provided we
       have a loose match to the name, accept it 
    */
    if((NULL != ICCGlobal_default[j].name) && (NULL != strstr(Global.funcs[i].name,ICCGlobal_default[j].name))) {
      ICCGlobal_default[i].func = Global.funcs[j].func;
    } else {
      SetStatusLn2 (NULL,status, ICC_ERROR, ICC_LIBRARY_NOT_FOUND,"Symbol not found in function list",(ICCGlobal_default[i].name != NULL) ? ICCGlobal_default[i].name : " prior internal self test failure " ,__FILE__,__LINE__);
      break;
    }
  }
  OUT();
}

static void LoadTables(ICC_STATUS *status)
{
  int i,j=0;
  IN();
  if(ICC_OK == status->majRC) {
    /* Populate the default ICCGlobal table */
    LoadTable(&(Global.status));
  

    memcpy(&ICCGlobal_Partial,&ICCGlobal_default, sizeof(ICCGlobal_Partial));
    memcpy(&ICCGlobal_Error,&ICCGlobal_default, sizeof(ICCGlobal_Error));  
    /* Now winnow the entry points down 
       Error state table, I know, but really, it's accurate enough
    */
    for (i = 0; i < (NUM_ICCLIBFUNCTIONS - 1); i++) {
      if (NULL == ICCGlobal_Error[i].name)
        break;
      if ((NULL != strstr(ICCGlobal_Error[i].name, "_new")) ||
          (NULL != strstr(ICCGlobal_Error[i].name, "generate")) ||
          (NULL != strstr(ICCGlobal_Error[i].name, "Generate")) ||
          (NULL != strstr(ICCGlobal_Error[i].name, "Init")) ||
          (NULL != strstr(ICCGlobal_Error[i].name, "get_")) ||
          (NULL != strstr(ICCGlobal_Error[i].name, "RAND_")) ||
          (NULL != strstr(ICCGlobal_Error[i].name, "DES_random_key")) ||
          (NULL != strstr(ICCGlobal_Error[i].name, "AES_CCM_Encrypt")) ||
          (NULL != strstr(ICCGlobal_Error[i].name, "AES_CCM_Decrypt")) ||
          (NULL != strstr(ICCGlobal_Error[i].name, "SP800_38F_KW"))) {
        ICCGlobal_Error[i].func = NULL;
      }
    } 
    /* Init table is a bit simpler 
       anything beyond SelfTest isn't there
    */
    for(i = 0; i <  (NUM_ICCLIBFUNCTIONS-1); i++) {
      if(NULL == ICCGlobal_Partial[i].name) break;
      if(NULL != strstr(ICCGlobal_Partial[i].name,"SelfTest")) {
	      j = 1; 
	      continue;
      }
      if( 0 != j) {
	      ICCGlobal_Partial[i].func = NULL;
      }
    } 
  }
  OUT();
}

/*! @brief Open the ICC signature file and the ICC shared library
  @param sigfile pointer to the file descriptor pointer for ICCSIG.txt or equivalent
  @param self pointer to the file descriptor pointer for ourself (shared library)
  @param self may be NULL , sigfile must always be non-NULL
*/
void OpenCheckFiles(FILE **sigfile,FILE **self) 
{

  static char tmppath[MAX_PATH+1];
  char *ptr = NULL;
#if defined(_WIN32)
  static wchar_t tmppathW[MAX_PATH+1];
  wchar_t *wptr = NULL;
#endif
  IN();

  FUNCTION_NAME(MYNAME,_path)(tmppath,MAX_PATH-20);
  strncat(tmppath,"/",MAX_PATH);
  ptr = tmppath + strlen(tmppath);
#if defined(STANDALONE_ICCLIB)
  strncat(tmppath,"ICCLIB_SA.txt",MAX_PATH); 
#else
  strncat(tmppath,"ICCSIG.txt",MAX_PATH);
#endif
  *sigfile = fopen(tmppath,"rb");
  MARK(tmppath,(*sigfile) != NULL ? "Opened ICCSIG.txt": "Failed Open ICCSIG.txt");
  /** \induced 150. Signature test, fopen() failed on external file
      in ASCCI mode. (Differs from 151 only on Windows platforms)
   */    
  if(150 == icc_failure) {
    fclose(*sigfile);
    *sigfile = NULL;
  }

#if defined(_WIN32)
  if(NULL == *sigfile) {
    ptr = NULL;
    FUNCTION_NAME(MYNAME,_pathW)(tmppathW,MAX_PATH-20); 
    wcsncat(tmppathW,L"/",MAX_PATH);
    wptr = tmppathW + wcslen(tmppathW);
#   if defined(STANDALONE_ICCLIB)
    wcsncat(tmppathW,L"ICCLIB_SA.txt",MAX_PATH); 
#   else
    wcsncat(tmppathW,L"ICCSIG.txt",MAX_PATH);
#   endif    
    *sigfile = _wfopen(tmppathW,L"rb");
    MARK("wchar_t path",(*sigfile) != NULL ? "Opened ICCSIG.txt": "Failed Open ICCSIG.txt");
    if(NULL != *sigfile) {
      Global.unicode = 1;
    }
  }

#endif

  /** \induced 151. Signature test, fopen() failed on external file.
   */    
  if(151 == icc_failure) {
    fclose(*sigfile);
    *sigfile = NULL;
  }

  if (ICC_OK == Global.status.majRC)
  {
    if (NULL != self)
    { /* Don't always open self */
      if (NULL != ptr)
      {
        *ptr = '\0';
        strncat(tmppath, ICCDLL_NAME, MAX_PATH);
        *self = fopen(tmppath, "rb");
      }
#if defined(_WIN32)
      else if (NULL != wptr)
      {
        *wptr = L'\0';
        MultiByteToWideChar(CP_ACP, 0, ICCDLL_NAME, -1, wptr, MAX_PATH - 1);
        *self = _wfopen(tmppathW, L"rb");
      }
#endif
      /** \induced 152. Signature test, Signature test, fopen() failed on self.
     */
      if (152 == icc_failure)
      {
        fclose(*self);
        *self = NULL;
      }
    }
  }
  if(NULL == *sigfile) {
    SetStatusLn2(NULL,&(Global.status),ICC_ERROR | ICC_FATAL,ICC_LIBRARY_VERIFICATION_FAILED,"External signature file could not be opened",tmppath,__FILE__,__LINE__);
  }
  
  if((NULL != self) && (NULL == *self)) {
    SetStatusLn2(NULL,&(Global.status),ICC_ERROR | ICC_FATAL,ICC_LIBRARY_VERIFICATION_FAILED,"Could not open file for verification",tmppath,__FILE__,__LINE__);
  }

  OUT();
}
/*!
  @brief
  Set up so that it's called by shared library loading
  See platfsl.c
  @return 0 on sucess, !0 otherwise
*/
int ICCLoad ()
{
  int rc = 0;
  int runpost = 1;
  FILE *sigfile = NULL;
  int trc = ICC_OSSL_SUCCESS;
  char *params[20];
  long long cap = 0LL;
  char cpuid[30];

  TRACE_START_EX("icclib",NULL);
  IN();
#if defined(STANDALONE_ICCLIB)
  Delta_T(1,&d[0]);
#endif
  MARK("OPENSSL_cpuid_setup()","Crypto capability probe");
  /* CPUID must be determined before we set TRNG's */
  OPENSSL_cpuid_setup();

  memset(params,0,sizeof(params));

#if (NON_FIPS_ICC == 0)
/* FIPS ICC, switch to FIPS TRNG by default */
  SetDefaultTrng(TRNG_FIPS);
#endif

  /* Load anything from the environment */
  EnvVars();
  
  OpenCheckFiles(&sigfile,NULL);


#if defined(STANDALONE_ICCLIB)
  d[1] = Delta_T(0,&d[0]);
#endif

  if(NULL != sigfile) {
    /* read config from the config file , this isn't signature checked !
       but all allowed values are equally valid in FIPS mode
       Note this caters for a NULL sigfile, ignores it, which is all we need
       Note 2: Yes, config file overrides environment settings.
       Delete from the config file if necessary.

    */
    MARK("ReadConfigItems","Read configuration from ICCSIG.txt");
    ReadConfigItems(sigfile,params,20);
    /* Note SetParams() cleans up the params list as it goes */
    if(NULL != sigfile) {
      fclose(sigfile);
    }   
    SetParams(params,20);    
  }
#if (NON_FIPS_ICC == 1) /* Built as non-FIPS */
  /* If we aren't the FIPS instance we won't run POST by default. 
     But run POST even if we are pretending we have FIPS as we need
     this for internal testing
   */
  if(!fips_lie) { /* Not pretending to be a FIPS module, POST off */
    runpost = 0;
  } else {
    if(!trng_set) {
      SetDefaultTrng(TRNG_FIPS);
      FIPS_mode_set(1);
    } else {
      fips_lie = 0;
    }
  }
  if(config_run_post) { /* Or if forced in the config file, on */
    runpost = 1;
  }
#else /* Built as FIPS */
  /* Default TRNG could have been changed by EnvVars() or ReadConfigItems() 
    so confirm we are still using a FIPS compliant TRNG at this point
  */
  TRNG_TYPE trng = GetDefaultTrng();
  if(!isFipsTrng(trng)) {
    fips_lie = 1; /* Drop us out of FIPS mode */
  } else {
     FIPS_mode_set(1);
  }
#endif



#if defined(STANDALONE_ICCLIB)
  d[2] = Delta_T(0,&d[0]);
#endif

  OpenSSL_Init(NULL,&(Global.status));

  init_name_caches();

#if defined(STANDALONE_ICCLIB)
  d[3] = Delta_T(0,&d[0]);
#endif
  if(runpost) {
    if(ICC_OK == Global.status.majRC ) {
      trc = SelfTest(NULL,&(Global.status)); 
    } else {
      SetFatalError("Self Test failed",__FILE__,__LINE__); /* Should be tripped earlier */
    }
  }
#if defined(STANDALONE_ICCLIB)
  d[4] = Delta_T(0,&d[0]);
#endif

  if(trc != ICC_OSSL_FAILURE) {
    Global.initialized = 1;
  } else {
    OpenSSL_Cleanup();
    SetFatalError("Could not initialize OpenSSL",__FILE__,__LINE__);
  }

  if(ICC_OK == Global.status.majRC ) {
    /* And check the binary only if we run full POST */
    rc =  InternalIntegrityCheck(NULL,&(Global.status),(runpost == 0));
    if((ICC_WARNING == rc) || (ICC_ERROR == rc)) {
       SetFatalError("Integrity check failed",__FILE__,__LINE__);
    }
  
  }
#if defined(STANDALONE_ICCLIB)
  d[5] = Delta_T(0,&d[0]);
#endif
  if(Global.status.majRC != ICC_ERROR) {
    LoadTables(&(Global.status));
    OPENSSL_cpuid(&cap);
    /* Should be snprinf but that can't be found on Windows */
    sprintf(cpuid,"%016llx",cap);
    MARK("CPUID",cpuid);
  }  



  OUTRC(rc);
  return rc;
}

/*!
  @brief
  Clean up the ICC global Mutex.
  This should be tripped by the ICC shared library unloading, 
  We do try to do this on platforms that support it, but
  unlike ICCLoad() it's not critical if it's not called
  @return 0 on sucess, !0 otherwise
*/
int ICCUnload ()
{
  int rc = 0;

  IN();
  ALT_Final(); /* Clean up fd used by TRNG_ALT */
  OpenSSL_Cleanup();
  if(NULL != exclude_list) {
    free(exclude_list);
    exclude_list = NULL;
  }

  OUTRC(rc);
  TRACE_END_EX();
  return rc;
}

/*!
  @brief Integrity check ICC. This is the check run during POST
  @param pcb ICC library context
  @param status status return
  @param partcheck Only check the signature file
  @return ICC_OK, ICC_ERROR,ICC_WARNING
  @note ICC_WARNING will be returned if the necessary files could not be opened
        preventing us from performing the checks
        close some files and retry.
        - This is considered a fatal error if it occurs during POST, at the application 
        level there is the possibility of closing files/sockets and retrying
  @note partcheck is used internally with non-FIPS ICC's, we read configuration
        from the signature file and checking that still matters
*/

int InternalIntegrityCheck(ICClib *pcb, ICC_STATUS *status, int partcheck)
{
  ICC_MAJOR_RC_ENUM rc = ICC_OK;
  int rv = 0;
  FILE *sigfile = NULL; /* File handle for the signature file */
  FILE *self = NULL;    /* File handle for ourself (shared lib) */
  EVP_PKEY *rsakey = NULL;
  IN();

  if (NULL == status)
  {
    rc = ICC_ERROR;
  }
  else
  {
    SetStatusOK(pcb, status);
  }
  if (ICC_OK == rc)
  {
    OpenCheckFiles(&sigfile, &self);
    if ((NULL == sigfile) || (NULL == self))
    {
      rc = SetStatusLn(pcb, status, ICC_WARNING, ICC_LIBRARY_VERIFICATION_FAILED, "Could not open files to perform integrity check", __FILE__, __LINE__);
    }
  }
  if (ICC_OK == rc)
  {
    rsakey = get_pubkey(status);
    if (NULL == rsakey)
    {
      rc = SetStatusLn(pcb, status, ICC_ERROR, ICC_LIBRARY_VERIFICATION_FAILED, "Could not create verification key", __FILE__, __LINE__);
    }
  }
  if (ICC_OK == rc)
  {
    rv = CheckSig(sigfile, self, rsakey, partcheck);
    /** \induced 154. Signature test, Signature test fails "unknown error"
	       basically a crypto. failure somewhere
    */
    if (154 == icc_failure)
    {
      rv = 3;
    }
    /** \induced 155. Signature test, Signature test fails, signature of self doesn't match
     */
    if (155 == icc_failure)
    {
      rv = 2;
    }
    /** \induced 156. Signature test, Signature test fails, signature of external signature file doesn't match
     */
    if (156 == icc_failure)
    {
      rv = 1;
    }
    switch (rv)
    {
    case 0:
      break;
    case 1:
      rc = SetStatusLn(pcb, status, ICC_ERROR | ICC_FATAL, ICC_LIBRARY_VERIFICATION_FAILED, "External signature file corrupt or incompatible", __FILE__, __LINE__);
      break;
    case 2:
      rc = SetStatusLn(pcb, status, ICC_ERROR | ICC_FATAL, ICC_LIBRARY_VERIFICATION_FAILED, "ICC crypto library file corrupt", __FILE__, __LINE__);
      break;
    case 3:
      rc = SetStatusLn(pcb, status, ICC_ERROR | ICC_FATAL, ICC_LIBRARY_VERIFICATION_FAILED, "Unknown error when verifying library", __FILE__, __LINE__);
      break;
    case 4: /* Shouldn't hit 4, NULL files */
      rc = SetStatusLn(pcb, status, ICC_WARNING, ICC_LIBRARY_VERIFICATION_FAILED, "Unable to open files to perform verification", __FILE__, __LINE__);
      break;
    default:
      break;
    }
  }
  if (NULL != sigfile)
  {
    fclose(sigfile);
  }
  if (NULL != self)
  {
    fclose(self);
  }
  if(NULL != rsakey) {
    EVP_PKEY_free(rsakey);
  }
  OUTRC(rc);
  return rc;
}
/*!
  @brief Integrity check ICC. 
  @param pcb ICC library context
  @param status status return
  @return ICC_OK, ICC_ERROR,ICC_WARNING
  @note Anything other than ICC_OK will result in the API shutting down. 
  This includes not enough files to perform the test (ICC_WARNING)
*/
int IntegrityCheck(ICClib *pcb, ICC_STATUS *status)
{
   int rc = ICC_OK;
   rc = InternalIntegrityCheck(pcb, status, 0);
    if((ICC_ERROR == rc) || (ICC_WARNING == rc)) {
       SetFatalError("Integrity check failed",__FILE__,__LINE__);
    }
    return rc;
}

/*!
  @brief
  Get status from OpenSSL access layer
  @param pcb ICC library context
  @param status status return
  @return ICC_OSSL_SUCCESS
*/
int GetStatus (ICClib * pcb, ICC_STATUS * status)
{

  if (status == NULL || pcb == NULL) {
    return ICC_FAILURE;
  }
  /* Yes, this is correct, if there's a terminal error
     SetStatus() called by SetStatusOK() handles that
  */
  SetStatusOK(pcb,status); 
  return ICC_OSSL_SUCCESS;
}


/*!
  @brief
  Initialize an ICClib structure
  @param pcb ICC internal context to be initialized
  @param status status return
  @param iccpath root path to icc libs. Actualy libraries are (hardwired) relative to this
  @param icclibhash FORMERLY ICC shared library signature
  - no longer used - either starts with 0 or 'W' to indicate iccpath is wchar_t
  @param cryptolibhash FORMERLY OpenSSL shared library signature, now unused
  @return the initialized ICClib structure or NULL on failure
*/

void *lib_init (ICClib * pcb, ICC_STATUS * status, const char *iccpath,
		const char *icclibhash, const char *cryptolibhash)
{
    /*
   * This is here only to keep agressive linkers from optimizing out our
   *    copyright/SCCS info.
   */
  const char *bogusVariable = ICC_SCCSInfo;
  struct ICClib_t *pcbt = NULL;

#ifdef OS400
  /* Not an ideal fix */
  struct iccsigs_t {
    const char *icclib;
    const char *icc400;
  } *iccsigs = (struct iccsigs_t*)icclibhash;

  const char *icc400hash = iccsigs->icc400;
  icclibhash = iccsigs->icclib;
#endif

  IN();
  /* Prevent compilers complaining about unused variables */
  tmp = bogusVariable[0];


  if (status == NULL) {
    return NULL;
  }
  SetStatusOK(NULL, status);

  if(getErrorState()) {
    ICC_GetLastError(status);
    return NULL;
  }

  pcbt = (ICClib *) ICC_Calloc (1,sizeof (ICClib),__FILE__,__LINE__);

  if (pcbt == NULL) {
    SetStatusMem (NULL,status,__FILE__,__LINE__);
    return NULL;
  }
  if (NULL != iccpath) {
    if ('\0' == Global.iccpath[0]) {
#if defined(_WIN32)
      if ((NULL != icclibhash) &&
          (*icclibhash == 'W')) { /* Wide char path handling */
        wcsncpy((wchar_t *)Global.iccpath, (wchar_t *)iccpath,
                sizeof(Global.iccpath) - sizeof(wchar_t));
        Global.unicode = 1;
      } else
#endif /* _WIN32 */
        strncpy(Global.iccpath, iccpath, sizeof(Global.iccpath) - 1);
    }
  }
  if( '\0' == Global.version[0]) {
    strncpy (Global.version,ICC_PRODUCT_VERSION,sizeof(Global.version));   
  }
  
  pcbt->length = sizeof (ICClib);
  /*now set the time, process and thread IDs */
  *(DWORD *) (pcbt->toi) = (DWORD) time (NULL);
  *(DWORD *) (pcbt->pIDinit) = ICC_GetProcessId ();
  *(DWORD *) (pcbt->tIDinit) = ICC_GetThreadId ();
  pcbt->funcs = ICCGlobal_Partial; /* Can only use a subset of functions before Attach */
#if (NON_FIPS_ICC == 1)
  /* The FIPS module is always initialized in FIPS mode 
    UNLESS the TRNG was changed
  */

    if(GetDefaultTrng() == TRNG_FIPS) {
      pcbt->flags |=  ICC_FIPS_FLAG;
    } else {
      MARK("Non-FIPS compliant TRNG configured, cannot enter FIPS mode","");
    }
#endif

  SetFlags(pcbt,status);
  OUTRC((NULL != pcbt));
  return (void *) pcbt;
}


/*!
  @brief set the callback for the mandatory FIPS indicator
         This is provided to allow the application to determine whether
         the function being called is a FIPS certified operation.
  @param pcb ICC internal context
  @param callback pointer to the callback function void (*callback)(const char *function,int nid,int status)
  @return 1 on success, 0 on failure (callback already set)
  @note - The callback is tied to the ICC_CTX
        - called before return from successful algorithm initialization
          or keygen. (Function failure has it's own indicators.)
        - function is the function that the callback came from
        - nid is the internal object ID of object.
          This may be somewhat abstracted in some cases, i.e. for an RNG
          it'll be the nid corresponding to the underlying algorithm
        - status is 1 if the object usage was valid for FIPS
          i.e. FIPS certified algorithm, key size acceptable etc.
        - First to set this per ICC_CTX wins
        - If you want to avoid the pain of sorting out threading issues
          use one ICC_CTX/thread
        - The callback is only removed by calling ICC_Cleanup()
          If occasional access only is required, use multiple ICC_CTX's  
*/
int SetFIPSCallback(ICClib *pcb, CALLBACK_T callback)
{
    int rv = 0;
    if((NULL != pcb) && (NULL == pcb->callback) && (pcb->flags & ICC_FIPS_FLAG)) {
      pcb->callback = callback;
      rv = 1;
    }
    return rv;
}

/*!
  @brief Set one of the internal ICC control values
  @param pcb ICC internal context
  @param status status return
  @param value pointer to value data
  @param valueID ID of value to set
  @return ICC_OSSL_SUCCESS or ICC_FAILURE
*/
int SetValue (ICClib * pcb, ICC_STATUS * status,ICC_VALUE_IDS_ENUM valueID,
		   const void *value)
{
  int rv = ICC_OK;

  IN();
  if (status == NULL) {
    return ICC_FAILURE;
  }
  SetStatusOK (NULL,status);	/* Default */
  /* We'll allow the memory callbacks and PRNG to be set before we've initialized anything
     as that's the only place we can do it and get consistent malloc()/free() pairing
     This isn't offically documented anywhere !.
  */
  if(NULL == pcb) {
    rv = ICC_FAILURE;
    switch(valueID) {
    case ICC_INDUCED_FAILURE:	
      icc_failure = *(unsigned int *)value;
      rv =  ICC_OK;
      break;
    default:
      break;
    }
    return rv;
  }
  if (pcb->lock != 0) {
    /* Allow only a few options once initialised */
    switch(valueID) {
      case ICC_INDUCED_FAILURE:
      case ICC_FIPS_CALLBACK:
      break;
      default:
      SetStatusLn (pcb,status, ICC_ERROR, ICC_INVALID_STATE,
		   (char *)"Attempted to set value while in locked state",
		   __FILE__,__LINE__);
      return ICC_FAILURE;
      break;
    }
  }
  if (value == NULL && (valueID == ICC_FIPS_APPROVED_MODE)) {
      SetStatusLn (pcb,status, ICC_ERROR, ICC_NULL_PARAMETER,
		   (char *)"Null parameters are not allowed for this ID",
		   __FILE__,__LINE__);
      return ICC_FAILURE;
    }
  switch (valueID) {
  case ICC_FIPS_APPROVED_MODE:
    MARK("ICC_FIPS_APPROVED_MODE",(char *)value);

 #if (NON_FIPS_ICC == 0)
    /* The FIPS version defaults to being in FIPS mode
      AND is reluctant to go into non-FIPS mode
      i.e. requires an override to do so
    */
    if (strcmp((char *)value, "off") == 0) {
      if (1 == fips_lie) {
        pcb->flags &= (~ICC_FIPS_FLAG);
        /* This is done so we can access the entropy taps
               in the FIPS ICC
              */
        if (NULL == exclude_list) {
          Set_rng_exclude(no_excluded_rngs);
        }
        break;
      }
    }
    if (strcmp((char *)value, "on") == 0) {
      pcb->flags |= ICC_FIPS_FLAG;
      break;
    }    
#else
    /* In a known non-FIPS release, we insist on a manual override
       before we'll allow the module to ENTER FIPS mode.
    */
    if (strcmp((char *)value, "on") == 0) {
      if (1 == fips_lie) {
        pcb->flags |= ICC_FIPS_FLAG;
        break;
      }
    }
    if (strcmp((char *)value, "off") == 0) {
      pcb->flags &= (~ICC_FIPS_FLAG);
      break;
    }
#endif
    SetStatusLn(pcb, status, ICC_ERROR, ICC_UNSUPPORTED_VALUE,
                (char *)"Invalid data value", __FILE__, __LINE__);
    break;
  case ICC_INSTALL_PATH:
    SetStatusLn(pcb, status, ICC_ERROR, ICC_UNSUPPORTED_VALUE_ID,
                (char *)"Attempted to set an unsettable value ID", __FILE__,
                __LINE__);
    break;
  case ICC_VERSION:
    SetStatusLn(pcb, status, ICC_ERROR, ICC_UNSUPPORTED_VALUE_ID,
                (char *)"Attempted to set an unsettable value ID", __FILE__,
                __LINE__);
    break;
  case ICC_MEMORY_ALLOC:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"Memory callbacks are unsafe (function deprecated, "
                        "value ignored)",
                __FILE__, __LINE__);
    break;
  case ICC_MEMORY_REALLOC:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"Memory callbacks are unsafe(function deprecated, "
                        "value ignored)",
                __FILE__, __LINE__);
    break;
  case ICC_MEMORY_FREE:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"Memory callbacks are unsafe(function deprecated, "
                        "value ignored)",
                __FILE__, __LINE__);
    break;
  case ICC_LOCKING_FUNCTION:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"Locking callbacks are unsafe(function deprecated, "
                        "value ignored)",
                __FILE__, __LINE__);
    break;
  case ICC_ID_FUNCTION:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"Locking callbacks are unsafe(function deprecated, "
                        "value ignored)",
                __FILE__, __LINE__);
    break;
  case ICC_RANDOM_GENERATOR:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"The PRNG must be set before POST", __FILE__, __LINE__);
    break;

  case ICC_SEED_GENERATOR:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"The TRNG must be set before POST", __FILE__, __LINE__);
    break;

  case ICC_RNG_INSTANCES:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"RNG instances must be set before POST", __FILE__,
                __LINE__);
    break;
  case ICC_RNG_TUNER:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"RNG tuner must be set before POST", __FILE__,
                __LINE__);
    break;
  case ICC_INDUCED_FAILURE:
    /* Note that this is gated by ICC_ALLOW_INDUCED being set during
       startup, not an issue for SUID processes as this is strictly
       for testing and the expectation is that the process will
       terminate.
     */
    if (NULL != value) {
      if (0 != icc_failure_mask) {
        icc_failure = *(unsigned int *)value;
        rv = ICC_OK;
      } else {
        SetStatusLn(
            pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
            (char *)"Attempted to set ICC_INDUCED_FAILURE when ICC was running",
            __FILE__, __LINE__);
      }
    } else {
      SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                  (char *)"The pointer to the induced failure was NULL",
                  __FILE__, __LINE__);
    }
    break;
  case ICC_CLEAN_AT_EXIT:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"The atexit() handler state before POST", __FILE__,
                __LINE__);
    break;
  case ICC_CPU_CAPABILITY_MASK:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"The CPU capability mask must be set before POST",
                __FILE__, __LINE__);
    break;
    case ICC_FIPS_CALLBACK:
      if( 0 == SetFIPSCallback(pcb,*(CALLBACK_T *)value) ) {
        SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"Callbacks are only valid in FIPS mode and the callback can only be set once/ICC_CTX",
                __FILE__, __LINE__);
      }
      MARK("ICC_FIPS_CALLBACK set","");
    break;

  default:
    SetStatusLn(pcb, status, ICC_ERROR, ICC_UNSUPPORTED_VALUE_ID,
                (char *)"Attempted to set an invalid value ID", __FILE__,
                __LINE__);
    break;
  }
  if ((ICC_OK == rv) && (ICC_OK != status->majRC)) {
    rv = status->majRC;
  }
  /* Note that the FIPS and ERROR bits are within the opaque ICC context
    we need to remember to copy that out to the ICC_STATUS as we exit */
  SetFlags(pcb,status);
  OUTRC(rv);
  return rv;
}

/*!
  @brief
  Get one of the internal ICC control values
  @param pcb ICC internal context
  @param status status return
  @param valueID ID of value to set
  @param value pointer to value data buffer
  @param valueLength the maximum allowed length of the returned value
  @return ICC_OSSL_SUCCESS or ICC_FAILURE
*/

int GetValue (ICClib * pcb, ICC_STATUS * status,ICC_VALUE_IDS_ENUM valueID,
		   void *value, int valueLength)
{
   int tmp = 0;
   int rv = ICC_OK;
   IN();
   if (status == NULL || pcb == NULL) {
      return ICC_FAILURE;
   }
   SetStatusOK (pcb,status);	/* Default */
   if (value == NULL) {
     SetStatusLn (pcb,status, ICC_ERROR, ICC_NULL_PARAMETER,
		(char *)"Null parameters are not allowed",
		  __FILE__,__LINE__);
      return ICC_FAILURE;
   }
   memset(value,0,valueLength);
   switch(valueID) {
   case ICC_ENTROPY_ESTIMATE:
   case ICC_RNG_INSTANCES:
   case ICC_RNG_TUNER:
   case ICC_ALLOW_INDUCED:
   case ICC_INDUCED_FAILURE:
   case ICC_LOOPS:
   case ICC_SHIFT:
     tmp = sizeof(int);
     break;
  case ICC_FIPS_CALLBACK:
    tmp = sizeof(CALLBACK_T);
    break;
   default:
     tmp = sizeof(void *);
     break;
   }

   if (valueLength < tmp) {
     SetStatusLn (pcb,status, ICC_ERROR, ICC_INVALID_PARAMETER,
		  (char *)"Value does not meet the minimum size requirement",
		  __FILE__,__LINE__);
     return ICC_FAILURE;
   }
   switch (valueID) {
   case ICC_FIPS_APPROVED_MODE:
     strncpy((char *)value, "off",valueLength);
     if (pcb->flags & ICC_FIPS_FLAG) {
       strncpy ((char *) value, "on",valueLength);
     }
     MARK("ICC_FIPS_APPROVED_MODE",(char *)value);
     break;
   case ICC_INSTALL_PATH:
     if (Global.iccpath[0] == '\0') {
       SetStatusLn (pcb,status, ICC_WARNING, ICC_VALUE_NOT_SET,
		    (char *)"Value has not been initialized",
		    __FILE__,__LINE__);
     }
#if defined(_WIN32)
     if (Global.unicode) {
       tmp = (wcslen((wchar_t *)Global.iccpath)) * (sizeof(wchar_t));
       if (tmp >= valueLength) {
         SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_TRUNCATED,
                     (char *)"Value has been truncated", __FILE__, __LINE__);
       }
       memset(value, valueLength, 0);
       wcsncpy((wchar_t *)value, (wchar_t *)Global.iccpath,
               (valueLength - 1) / sizeof(wchar_t));
     } else
#endif
     {
       tmp = strlen(Global.iccpath);
       if (tmp >= valueLength) {
         SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_TRUNCATED,
                     (char *)"Value has been truncated", __FILE__, __LINE__);
       }
       strncpy((char *)value, Global.iccpath, valueLength - 1);
       ((char *)value)[valueLength - 1] = '\0';
     }
     MARK("ICC_INSTALL_PATH", (NULL != value) ? (char *)value : "");
     break;
   case ICC_VERSION:
     strncpy ((char *) value, Global.version,valueLength-1);
     ((char *)value)[valueLength - 1] = '\0';
     MARK("ICC_VERSION",(char *)value);
     break;
   case ICC_MEMORY_ALLOC:
     *(void **) value = NULL;
     break;
   case ICC_MEMORY_REALLOC:
     *(void **) value = NULL;
     break;
   case ICC_MEMORY_FREE:
     *(void **) value = NULL;
     break;
   case ICC_LOCKING_FUNCTION:
     *(void **) value = NULL;
     break;
   case ICC_ID_FUNCTION:
     *(void **) value = NULL;
     break;
   case ICC_INDUCED_FAILURE:
     *(unsigned int *) value = icc_failure;
     break;
   case ICC_ALLOW_INDUCED:
     *(unsigned int *) value = icc_failure_mask;
     break;
   case ICC_CLEAN_AT_EXIT:
     *(unsigned int *) value = clean_at_exit;
     break;
   case ICC_ENTROPY_ESTIMATE:
     /*! \FIPS  return the current TRNG entropy estimate (FIPS140-3 draft requirement) */
     *(int *) value = RAND_FIPS_Entropy();
     MARK("ICC_ENTROPY_ESTIMATE","");
     break;
   case ICC_RANDOM_GENERATOR:
     strncpy((char *) value,GetPRNGName(),(valueLength < 19) ? valueLength: 19);
     MARK("ICC_RANDOM_GENERATOR",(char *)value);
     break;
   case ICC_SEED_GENERATOR:
     strncpy((char *) value,GetTRNGName(),(valueLength < 19) ? valueLength: 19);
     MARK("ICC_TRNG",(char *)value);
     break;
   case ICC_RNG_INSTANCES:
     *(int *)value = GetRNGInstances();
     MARK("ICC_RNG_INSTANCES","");
     break;
   case ICC_RNG_TUNER:
     *(int *)value = Get_default_tuner();
      MARK("ICC_RNG_TUNER","");
    break;
   case ICC_SHIFT:
     *(int *)value = Shift();
      MARK("ICC_SHIFT","");
    break;
    case ICC_LOOPS:
     *(int *)value = Loops();
      MARK("ICC_LOOPS","");
    break;
  case ICC_CPU_CAPABILITY_MASK:
     if(valueLength > 0) {
       *(char *)value = '\0';
     }
     if(valueLength < 17) {
       SetStatusLn (pcb,status, ICC_WARNING, ICC_INVALID_PARAMETER,
		    (char *)"Return field must be at least 17 bytes",
		    __FILE__,__LINE__);
     } else {
       long long cpuid = 0;
       if( 0 != OPENSSL_cpuid(&cpuid) ) {
	        sprintf((char *)value,"%016llx",cpuid);
       }
     }
     MARK("ICC_CPU_CAPABILITY_MASK",(value != NULL)? (char *)value:"");
     break;
   case ICC_FIPS_CALLBACK:
     *(CALLBACK_T *)value = pcb->callback;
      MARK("ICC_FIPS_CALLBACK","");
    break;
      
   default:
     SetStatusLn (pcb,status, ICC_ERROR, ICC_UNSUPPORTED_VALUE_ID,
		  (char *)"Attempted to get an invalid value ID",
		  __FILE__,__LINE__);
     rv = ICC_FAILURE;
     break;
   }
   if((ICC_OK == rv) && (ICC_OK != status->majRC)) {
     rv = status->majRC;
   }
   SetFlags(pcb,status);
   OUTRC(rv);
   return rv;
}




/*! 
  @brief
  - Perform consistancy checks on requested state.
  - Attach to the OpenSSL shared library
  - Initialize internal ICC state. (FIPS mode etc)
  - Initialize OpenSSL
  - Initialize PRNG seed
  - Run NIST self tests
  The ICC Mutex is held during this operation.
  - Most port errors happen here.
  @param pcb ICC internal context
  @param status status return
  @return ICC_OSSL_SUCCESS or ICC_FAILURE - Note need to check status.
*/
int lib_attach (ICClib * pcb, ICC_STATUS * status)
{
 
  int rc = ICC_OSSL_SUCCESS;

  IN();

  if (status == NULL || pcb == NULL) {
    return ICC_FAILURE;
  } 
  SetStatusOK (NULL,status);

  *(DWORD *) (pcb->toa) = (DWORD) time (NULL);
  *(DWORD *) (pcb->pIDattach) = ICC_GetProcessId ();
  *(DWORD *) (pcb->tIDattach) = ICC_GetThreadId ();
  
  if(getErrorState()) {
    rc = ICC_GetLastError(status);
  }
  if(ICC_OSSL_SUCCESS == rc) {
    if (3 == icc_failure) {
      Global.initialized = 0;
    }
    /*If not valid, return error */
    if ((0 == Global.initialized) && (ICC_OK == Global.status.majRC)) {
      /*Could not load DLL */
      SetStatusLn(pcb, status, ICC_ERROR | ICC_FATAL, ICC_INVALID_STATE,
                  (char *)"ICC was not initialized", __FILE__, __LINE__);
    }
    switch (status->majRC) {
    case ICC_ERROR:
    case ICC_OS_ERROR:
    case ICC_OPENSSL_ERROR:
      rc = ICC_FAILURE;
      break;
    case ICC_OK:
    case ICC_WARNING:
    default:
      /* Allow full set of crypto. functions */
      pcb->funcs = ICCGlobal_default;
      /*and prevent further state changes*/
      pcb->lock = 1;
      break;
    }
  }
  SetFlags(pcb,status);
  OUTRC(rc);
  return rc;
}

/*! @brief hook the OpenSSL RSA default method so we can
    force use of X9.31 keygen
    @param icc_stat  error return 
    @return ICC_OSSL_SUCESS or ICC_FAILURE
*/

typedef int (*PF_keygen)(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);

static int iccSetUpRSAFIPS(ICC_STATUS *icc_stat)
{
   const RSA_METHOD *def = NULL;
   int ret = ICC_OSSL_SUCCESS;
   IN();
#if 1 
   def = RSA_get_default_method();
   
   if(NULL != def && NULL == FIPS_RSA_meth) {

     FIPS_RSA_meth = RSA_meth_dup(def);
     /** \induced 170. Failure to set RSA keygen to X9.31 method */
     if(170 == icc_failure) {
       /* Yes, do nothing */
     } else {
#if defined(_WIN32)
       RSA_meth_set_keygen(FIPS_RSA_meth,fips_rsa_builtin_keygen);
#else       
       RSA_meth_set_keygen(FIPS_RSA_meth, (PF_keygen)fips_rsa_builtin_keygen);
#endif
       RSA_set_default_method((const RSA_METHOD *)FIPS_RSA_meth);
     }   
   } 
   if( (const RSA_METHOD *)FIPS_RSA_meth != RSA_get_default_method() ) {
     SetStatusLn(NULL,icc_stat,ICC_ERROR | ICC_FATAL,ICC_LIBRARY_VERIFICATION_FAILED,
		                  "Failed to setup the FIPS compliant RSA key generator",__FILE__,__LINE__); 
     ret = ICC_FAILURE;
     MARK("Failed to setup FIPS RSA keygen","");
   }
#endif    
   OUTRC(ret);
   return ret;         
}

/*! @brief Initialize OpenSSL
  Only called in the library load path 
*/
static void OpenSSL_Init(ICClib *pcb, ICC_STATUS * status)
{
  IN();

  /* Make sure this is done before we do any crypto */
  MARK("OPENSSL_cpuid_setup()","");
  OPENSSL_cpuid_setup();

  if(ICC_OK == status->majRC) {

    MARK("OPENSSL_init_crypto(OPENSSL_INIT_NO_LOAD_CONFIG | OPENSSL_INIT_NO_ATEXIT | OPENSSL_INIT_LOAD_CRYPTO_STRINGS | OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_ADD_ALL_CIPHERS)","");

    OPENSSL_init_crypto(
            OPENSSL_INIT_NO_LOAD_CONFIG | OPENSSL_INIT_NO_ATEXIT |
            OPENSSL_INIT_LOAD_CRYPTO_STRINGS |
            OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_ADD_ALL_CIPHERS,
            NULL);

    iccLoadErr (status);
    /* Set the FIPS RNG methods */
    if(ICC_OK == status->majRC) {
      /* Note, the RNG's now auto-seed/reseed */
      iccSetRNG(pcb, status,NULL,0);
    }
    /* Set the RSA FIPS method */
    if(ICC_OK == status->majRC) {
      iccSetUpRSAFIPS (status);
    }
    FIPS_init_flag = 1;

  } 
  OUT();
}

   
/*! @brief Cleanup OpenSSL 
     Only called in the library unload path
*/
static void OpenSSL_Cleanup()
{ 
  IN();

  if(NULL != FIPS_RSA_meth) {
    RSA_meth_free(FIPS_RSA_meth);
    FIPS_RSA_meth = NULL;
  }
  OPENSSL_cleanup();
  
  /* Remove our RNG hooks */
  iccCleanupRNG();
  /* Cleanup mutexes on the PRNG TYPES 
     These protect the instantiation counter only
   */
  CleanupSP800_90(); 


  OUT();
}
/*! 
  @brief Load ICC specific error strings into OpenSSL's error tables
  @param status the error status
*/
  
static void iccLoadErr(ICC_STATUS* status)
{
    ERR_STRING_DATA (*temp)[]=NULL;
    ERR_load_crypto_strings();
    get_ICC_str_libraries(&temp);
    ERR_load_strings(ICC_ERR_L_ICC, *temp);
    get_ICC_str_functions(&temp);
    ERR_load_strings(ICC_ERR_L_ICC, *temp);
    get_ICC_str_reasons(&temp);
    ERR_load_strings(ICC_ERR_L_ICC, *temp);
    getPrngErrFuncts(&temp);
    ERR_load_strings(ERR_LIB_RAND, *temp);
    getPrngErrReasons(&temp);
    ERR_load_strings(ERR_LIB_RAND, *temp);
}

/*! 
  @brief
  Cleanup an ICC context.
  @param pcb ICC internal context
  @param status status return
  @return ICC_OSSL_SUCCESS or ICC_FAILURE
  @note As of ICC8.x this does very little the call table
  is now global and we defer all the heavy duty lifting until
  we are being unloaded.
*/
int lib_cleanup (ICClib *pcb,ICC_STATUS * status)
{
  int rv = ICC_OSSL_SUCCESS;
  IN();
  if (status == NULL || pcb == NULL) {
     rv = ICC_FAILURE;
  }
  /* Note NO SetStatusOK() here as that will return the last 
     error on a hard error, and we want a clean escape 
     on an ICC_Cleanup() call. 
     It's set correctly by the higher level code, but called here 
     will return the persistant error
  */
  if(ICC_OSSL_SUCCESS == rv) {
    ICC_Free(pcb);
    if (status->majRC != ICC_OK) {
      rv = ICC_FAILURE;
    }
  }  
  OUTRC(rv);
  return rv;
}

/*!
  @brief
  Self test code
  - run NIST mandated self tests
  @param pcb ICC internal context
  @param status status return
  @return ICC_OSSL_SUCCESS or ICC_FAILURE
*/
int SelfTest (ICClib *pcb,ICC_STATUS * status)
{
  int iccRC = ICC_OSSL_SUCCESS;

	
  MARK("SelfTest","iccDoKnownAnser");
  /*! \FIPS call the known answer tests during POST */
  iccDoKnownAnswer (pcb, status);
  if (status->majRC != ICC_OK) {
    iccRC = ICC_OSSL_FAILURE;
    /* And if it's a FIPS context or POST, make sure this
       is remembered for all future FIPS contexts
    */
    MARK("SelfTest","failed");
    SetStatusLn(pcb,status,ICC_ERROR | ICC_FATAL,ICC_LIBRARY_VERIFICATION_FAILED,"Self Test failed",__FILE__,__LINE__);
  }
  OUTRC(iccRC);
  return iccRC;
}


/*!
  @brief
  OpenSSL calloc function
  @param n the number of blocks to allocate
  @param sz the size of each block
  @param file __FILE__, file where the allocation was requested
  @param line __LINE__, line where the allocation was requested
  @return NULL or the newly allocated block
  @note OpenSSL doesn't provide a calloc, so we call it's malloc and then
  memset() the area to 0
*/
void *CRYPTO_calloc(int n,int sz,const char *file, int line)
{
  void *tmp = NULL;
  tmp = CRYPTO_malloc(n*sz,file,line);
  if(NULL != tmp) {
    memset(tmp,0,n*sz);
  }
  return tmp;
}

/*! 
  @brief
  Free an MD context
  @param x pointer to an existing MD context
  @return ICC_OSSL_SUCCESS or ICC_OSSL_FAILURE
*/
int my_EVP_MD_CTX_free (EVP_MD_CTX * x)
  {
   if (x != NULL) {
     EVP_MD_CTX_cleanup(x);     
     ICC_Free (x);
     return ICC_OSSL_SUCCESS;
   }
   return ICC_OSSL_FAILURE;
}

/*! 
  @brief
  Free an ENCODE context
  @param x pointer to an existing ENCODE context
  @return ICC_OSSL_SUCCESS or ICC_OSSL_FAILURE
*/

int my_EVP_ENCODE_CTX_free (EVP_ENCODE_CTX * x)
{
   if (x != NULL) {
     ICC_Free(x);
     return ICC_OSSL_SUCCESS;
   }
   return ICC_OSSL_FAILURE;
}



int EVP_MD_CTX_init(EVP_MD_CTX *ctx) 
{
  return EVP_MD_CTX_reset(ctx);
}
int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx) 
{
  return EVP_MD_CTX_reset(ctx);
}
int EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *ctx) 
{
  return EVP_CIPHER_CTX_reset(ctx);
}
int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *ctx) 
{
  return EVP_CIPHER_CTX_reset(ctx);
}
int EVP_CIPHER_CTX_flags(EVP_CIPHER_CTX *ctx) 
{
  return EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx));
}

/*! 
  @brief
  Free an EVP_CIPHER context
  @param x pointer to an existing EVP_CIPHER context
  @return ICC_OSSL_SUCCESS or ICC_OSSL_FAILURE
*/
int my_EVP_CIPHER_CTX_free(EVP_CIPHER_CTX * x)
{
     
  EVP_CIPHER_CTX_free(x);
  return ICC_OSSL_SUCCESS;
}

#undef HMAC_CTX_cleanup
int HMAC_CTX_cleanup(HMAC_CTX *ctx)
{
  return HMAC_CTX_reset(ctx);
}  

/*! @brief initializes or reuses a HMAC_CTX structure to use the;
      function evp_md and key key. Either can be NULL, in which case the;
      existing one will be reused.
 @param ctx a previously created HMAC_CTX;
 @param key the key;
 @param key_len length of the key in bytes;
 @param md A pointer to the EVP_MD structure containing the hash information;
*/

int my_HMAC_Init(HMAC_CTX *ctx, const void *key, int key_len,const EVP_MD *md)
{
  return HMAC_Init_ex(ctx,key,key_len,md,NULL);
}


/*! @brief Update phase of a CMAC operation
    @param cmac_ctx a pointer to a CMAC_CTX
    @param cipher the cipher to use
    @param key the CMAC key
    @param keylen the length of the CMAC key
    @note blocked/aligned data will be more efficient, but this will
          survive incorrectly blocked/misaligned data
*/
int my_CMAC_Init(CMAC_CTX *cmac_ctx,const EVP_CIPHER *cipher,unsigned char *key,unsigned int keylen)
{
  return CMAC_Init(cmac_ctx,key,keylen,cipher,NULL);

}
/* @brief Finish a CMAC operation and return the CMAC value;
    @param cmac_ctx a pointer to a CMAC_CTX;
    @param md a pointer to a buffer in which to store the CMAC;
    @param maclen the desired CMAC length (0 <= md_len <= Cipher block size);
    @return 1 on success, 0 on failure;
    @note a request for an overly long mac will result in an error;
*/
int my_CMAC_Final(CMAC_CTX *cmac_ctx,unsigned char *md,unsigned int maclen)
{
  size_t outlen = maclen;
  return CMAC_Final(cmac_ctx,md,&outlen);
}


/*!
  @brief
  Return a pointer to the BIGNUM inside a DH structure which contains the DH public key
  NOTE: This does NOT allocate a new BIGNUM. Do NOT free this value.
  @param dh DH context
  @return a pointer to the internal field of the DH containing the public key
*/
const BIGNUM *DH_get_PublicKey (const DH * dh)
{
   const BIGNUM *pub_key;
   DH_get0_key((DH *)dh,&pub_key,NULL);
   return pub_key;
}

/*!
  @brief
  Return a pointer to the BIGNUM inside a DH structure which contains the DH private key
  - NOTE: This does NOT allocate a new BIGNUM. Do NOT free this value.
  - I suspect this isn't needed / shouldn't be provided  
  @param dh DH context
  @return a pointer to the internal field of the DH containing the private key
*/
const BIGNUM *DH_get_PrivateKey (const DH * dh)
{
   const BIGNUM *priv_key;
   DH_get0_key((DH *)dh,NULL,&priv_key);
   return priv_key;
}

/*!
   @brief sets up digest context ctx to use the specified digest type;
   @param ctx pointer to the EVP_MD_CTX;
   @param type pointer to an EVP_MD;
   @return ICC_OSSL_SUCCESS, ICC_OSSL_FAILURE;
   @note calls EVP_DigestInitEx() which has different behaviour from EVP_DigestInit()
*/
int  my_EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type)
{
  return EVP_DigestInit_ex(ctx,type,NULL);
}

/*! @brief retrieves the digest value and returns it to the requesting application.;
    @param ctx pointer to the EVP_MD_CTX;
   @param md pointer to buffer which will contain the hash;
   @param s pointer to an integer to hold the size of the hash
*/
int my_EVP_DigestFinal(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *s)
{
  return EVP_DigestFinal_ex(ctx,md,s);
}

/*!
 @brief sets up cipher context ctx for encryption 
 @param ctx the cipher context to use
 @param type the cipher to use
 @param key the key to use
 @param iv the iv to use.
 @note this vectors to EVP_EncryptInit_ex() rather than EVP_EncryptInit() as this the _ex() entry point 
 is more flexible and allows us to set rc2 key length etc.
 @return ICC_OSSL_SUCCCESS, ICC_OSSL_FAILURE

*/
int my_EVP_EncryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,unsigned char *key, unsigned char *iv) 
{
  return EVP_EncryptInit_ex(ctx,type,NULL,key,iv);
}

/*!
 @brief sets up cipher context ctx for encryption 
 @param ctx the cipher context to use
 @param type the cipher to use
 @param key the key to use
 @param iv the iv to use.
 @note this vectors to EVP_DecryptInit_ex() rather than EVP_DecryptInit() as this the _ex() entry point 
 is more flexible and allows us to set rc2 key length etc.
 @return ICC_OSSL_SUCCCESS, ICC_OSSL_FAILURE
*/
int my_EVP_DecryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,unsigned char *key, unsigned char *iv) 
{
  return EVP_DecryptInit_ex(ctx,type,NULL,key,iv);
}


/*!
  @brief Create a new RSA context
  @param pcb the ICC library context
  @return A new RSA context or NULL on failure
*/
RSA * my_RSA_new(ICClib *pcb) 
{
  RSA *rsa = NULL;

  rsa = RSA_new();

  return rsa;
} 
  
int my_EVP_PKEY_decrypt(unsigned char *dec_key,unsigned char *enc_key,int enc_key_len,EVP_PKEY *private_key) {
  return EVP_PKEY_decrypt_old(dec_key,enc_key,enc_key_len,private_key);
  
}

int my_EVP_PKEY_encrypt(unsigned char *enc_key,unsigned char *key,int key_len,EVP_PKEY *pub_key) {
  return EVP_PKEY_encrypt_old(enc_key,key,key_len,pub_key);
} 
/* Tolerate NUMM status here because it was ignored for a long long time */
void GenerateRandomSeed(ICClib *pcb, ICC_STATUS *status,int num, unsigned char *buff) {
  if(NULL != status) {
    SetStatusOK(pcb,status);
  }  
  if(0 == my_GenerateRandomSeed(num,buff) )
  {
    if(NULL != status) {
      SetStatusLn(pcb,status,ICC_ERROR,ICC_DISABLED,(char *)"RNG seed source failed",__FILE__,__LINE__);
    }   
  }	  
}


RSA *  my_RSA_generate_key(ICClib *pcb,int bits, unsigned long e,void (*callback)(int,int,void *),void *cb_arg)
{
  RSA *rsa = NULL;
  BIGNUM *ebn = NULL;
  int i = 0;

  rsa = RSA_new();
  ebn = BN_new();
  if ((NULL != rsa) && (NULL != ebn))
  {
    for (i = 0; i < (int)sizeof(e) * 8; i++)
    {
      if (e & (1UL << i))
      {
        BN_set_bit(ebn, i);
      }
    }

    if (1 != my_RSA_generate_key_ex(pcb, rsa, bits, ebn, NULL))
    {
      RSA_free(rsa);
      rsa = NULL;
    }
    BN_clear_free(ebn);
  }
  return rsa;
}
/*
  Note: We use this code in both FIPS and non-FIPS modes so the policy checks that were 
  in OpenSSL are lifted and done at this level instead
  i.e. valid FIPS key size range and minimum exponent size

*/

int my_RSA_generate_key_ex(ICClib *pcb, RSA *rsa, int bits, BIGNUM *e, void *callback)
{
  int rv = 1;
  int nid = 0;
  int fips = 0;
  BIGNUM *elim = NULL;
  /* Overall sanity check, the KeyPair check has a fixed length buffer but this is sane even in non-FIPS mode  */
  if (bits < 512 || bits > 16384)
  {
    rv = 0;
  }
  /* Unlike OpenSSL, we make the policy decisions, key size, exponent at this level 
    and are more permissive if not in FIPS mode.
  */
  if ((1 == rv) && (pcb->flags & ICC_FIPS_FLAG))
  {
    elim = BN_new();
    BN_set_word(elim, 0x10001);
    if ((bits < 2048) || (bits > 8192) || (BN_cmp(e, elim) < 0) || !BN_is_odd(e) || (BN_num_bits(e) > 256))
    {
      rv = 0;
    }
    BN_free(elim);
  }
  if (1 == rv)
  {
    RAND_seed(NULL,0); /* Reseed the RNG before keygen */
    rv = RSA_generate_key_ex(rsa, bits, e, callback);
  }

  if ((1 == rv) && (pcb->flags & ICC_FIPS_FLAG))
  {
    /* The RSA size check here is to cater for the NIST test case where the key is preloaded with P&Q 
      keygen isn't actually done so rsa->n is 0 length. 
      The key isn't usable but this borked key has to pass to get through FIPS
    */
    if (ICC_OK != iccRSAKeyPair(pcb, rsa))
    {
      rv = 0;
    }
    else
    {
      fips = 1;
    }
  }
  if (1 == rv)
  {
    if (NULL != pcb->callback)
    {
      nid = 19;
      (*pcb->callback)("ICC_RSA_generate_key_ex", nid, fips);
    }
  }
  return rv;
}

DH * my_DH_generate_parameters(ICClib *pcb,int bits, int generator,void (*callback)(int,int,void *),void *cb_arg)
{
  DH *temp = NULL;
  temp = DH_generate_parameters(bits, generator,callback,cb_arg);
  if((NULL != pcb->callback) && (NULL != temp)) {
    (*pcb->callback)("ICC_DH_generate_parameters",946,0); /* Never FIPS compliant */
  }
  return temp;
}
DSA * my_DSA_generate_parameters(ICClib *pcb,int bits,unsigned char *seed,int seed_len,int *counter_ret, unsigned long *h_ret,void (*callback)(int, int, void *),void *cb_arg)
{
  DSA *temp = NULL;
  RAND_seed(NULL,0); /* Reseed the RNG before keygen */
  temp = DSA_generate_parameters(bits,seed,seed_len,counter_ret,h_ret,callback,cb_arg);
  if((NULL != pcb->callback) && (NULL != temp)) {
    (*pcb->callback)("ICC_DSA_generate_parameters",116,0); /* Never FIPS compliant */
  }
  return temp; 

}
int my_DSA_generate_key(ICClib *pcb, DSA *a) {
  int temp = ICC_FAILURE;

  int i = 0;
  if ((NULL != pcb) && !((pcb->flags & ICC_FIPS_FLAG) && getErrorState())) {
    RAND_seed(NULL,0); /* Reseed the RNG before keygen */
    temp = DSA_generate_key(a);
    if (pcb->flags & ICC_FIPS_FLAG) {
      if (NULL != a) {
        for (i = 0; i < 5; i++) {
          if ((NULL == a->pub_key) ||
              (((BN_num_bits(a->pub_key) + 7) / 8) < (1024 / 8)) ||
              (ICC_OK != iccDSAPairTest(pcb, a))) {
            temp = DSA_generate_key(a);
          } else {
            break;
          }
        }
        if (5 == i) {
          if (a->pub_key != NULL) {
            BN_clear_free(a->pub_key);
            a->pub_key = NULL;
          }
          if (a->priv_key != NULL) {
            BN_clear_free(a->priv_key);
            a->priv_key = NULL;
          }
          temp = ICC_FAILURE;
        }
      }
    }
    if((NULL != pcb->callback) && (0 != temp)) {
      (*pcb->callback)("ICC_DSA_generate_key",116,0); /* Never FIPS compliant */
    }
  }
  return temp;
}
EC_KEY *my_EC_KEY_new_by_curve_name(ICClib *pcb,int nid)
{
  EC_KEY *temp = NULL;
  int fips = 0;
  temp = EC_KEY_new_by_curve_name(nid);
  if(NULL != temp) {
    switch (nid)
    {
    case 713: /* secp224r1  P-224 */
    case 415: /* prime256v1 P-256 */
    case 715: /* secp384r1  P-384 */
    case 716: /* secp521r1  P-521 */
    case 726: /* sect233k1  K-233 */
    case 727: /* sect233r1  B-233 */
    case 729: /* sect283k1  K-283 */
    case 730: /* sect283r1  B-283 */
    case 731: /* sect409k1  K-409 */
    case 732: /* sect409r1  B-409 */
    case 733: /* sect571k1  K-571 */
    case 734: /* sect571r1  B-571 */
      fips = 1;
      break;
    default:
      break;
    }
    if(NULL != pcb->callback) {
      (*pcb->callback)("ICC_EC_KEY_new_by_curve_name",nid,fips);
    } 
  }
  return temp;
}
int my_EC_KEY_generate_key(ICClib *pcb, EC_KEY *eckey) {
  int temp = ICC_FAILURE;
  if ((NULL != pcb) && !((pcb->flags & ICC_FIPS_FLAG) && getErrorState())) {
    RAND_seed(NULL,0); /* Reseed the RNG before keygen */
    temp = EC_KEY_generate_key(eckey);
    if (pcb->flags & ICC_FIPS_FLAG) {
      if ((((ECDSA_size(eckey) - 8) / 2) < 20) ||
          (ICC_OK != iccECKEYPairTest(pcb, eckey))) {
        temp = (int)ICC_FAILURE;
      }
    }
  }
  return temp;
}


int my_RAND_bytes(unsigned char *buf,int n)
{
  int rv = 0;
  rv = RAND_pseudo_bytes(buf,n);
  return rv;
}
int my_EVP_PKEY_decrypt_new(EVP_PKEY_CTX *ctx, 
			    unsigned char *out, size_t *outlen,
			    const unsigned char *in, size_t inlen) {
  return EVP_PKEY_decrypt(ctx,out,outlen,in,inlen);  
}

int my_EVP_PKEY_encrypt_new(EVP_PKEY_CTX *ctx, 
			    unsigned char *out, size_t *outlen,
			    const unsigned char *in, size_t inlen) {
  return EVP_PKEY_encrypt(ctx,out,outlen,in,inlen);  
}



unsigned char *my_HKDF_Extract(const EVP_MD *evp_md,
                            const unsigned char *salt, size_t salt_len,
                            const unsigned char *key, size_t key_len,
                            unsigned char *prk, size_t *prk_len)
{
    unsigned int tmp_len;
    HMAC_CTX *hmac = NULL;
    hmac = HMAC_CTX_new();
    HMAC_Init(hmac,salt, (int)salt_len, evp_md);
    HMAC_Update(hmac,key,key_len);
    HMAC_Final(hmac,prk,&tmp_len);
    HMAC_CTX_free(hmac);
    *prk_len = tmp_len; 
    return prk;
}

unsigned char *my_HKDF_Expand(const EVP_MD *evp_md,
                           const unsigned char *prk, size_t prk_len,
                           const unsigned char *info, size_t info_len,
                           unsigned char *okm, size_t okm_len)
{
  unsigned char *ret = okm;
  HMAC_CTX *hmac = NULL;
  unsigned int i =0;
  unsigned char prev[ICC_EVP_MAX_MD_SIZE];
  size_t copy_len = 0;
  unsigned char ctr = 0;
  size_t done_len = 0;
  size_t dig_len = 0;
  size_t n = 0;


  dig_len = EVP_MD_size(evp_md);

  n = okm_len / dig_len;
  if (okm_len % dig_len) {
      n++;
  }
  if (n > 255 || okm == NULL) {
    ret = NULL;
  }
  if (NULL == (hmac = HMAC_CTX_new())) {
    ret = NULL;
  }
  if( NULL != hmac) {
    if (!HMAC_Init(hmac, prk, (int)prk_len, evp_md)) {
      ret = NULL;
    } else {
      for (i = 1; (i <= n); i++) {
        ctr = (unsigned char)i;
        if (i > 1) {
          if (!HMAC_Init(hmac, NULL, 0, NULL)) {
            ret = NULL;
            break;
          }
          HMAC_Update(hmac, prev, dig_len);
        }
        HMAC_Update(hmac, info, info_len);
        HMAC_Update(hmac, &ctr, 1);
        HMAC_Final(hmac, prev, NULL);
        copy_len = (done_len + dig_len > okm_len) ? (okm_len - done_len) :dig_len;
        memcpy(okm + done_len, prev, copy_len);
        done_len += copy_len;
      }
    }
    HMAC_CTX_free(hmac);
  }
  memset(prev,0,sizeof(prev));
  return ret;
}
unsigned char *my_HKDF(const EVP_MD *evp_md,
                       const unsigned char *salt, size_t salt_len,
                       const unsigned char *key, size_t key_len,
                       const unsigned char *info, size_t info_len,
                       unsigned char *okm, size_t okm_len)
{
  unsigned char prk[ICC_EVP_MAX_MD_SIZE];
  unsigned char *ret;
  size_t prk_len;

  if (!my_HKDF_Extract(evp_md, salt, salt_len, key, key_len, prk, &prk_len))
  {
    ret = NULL;
  }
  else
  {
    ret = my_HKDF_Expand(evp_md, prk, prk_len, info, info_len, okm, okm_len);
  }
  memset(prk, 0, sizeof(prk));

  return ret;
}
#if 0
/* Copied from crypto/dsa/dsa_meth.c, see the comments, the droid we want isn't here */
typedef struct {
    /* Parameter gen parameters */
    int nbits;                  /* size of p in bits (default: 2048) */
    int qbits;                  /* size of q in bits (default: 224) */
    const EVP_MD *pmd;          /* MD for parameter generation */
    /* Keygen callback info */
    int gentmp[2];
    /* message digest */
    const EVP_MD *md;           /* MD for the signature */
} DSA_PKEY_CTX;
#endif
/*! @brief generic FIPS checker for pkeys
  @param pk The input pkey
  @param check 0 not capable of doing a sign/verify check. 1 capable of doing a sign/verify check on keygen
        2 Verify only is FIPS approved
  @param nid NID of the algorithm if it can be identified
*/
static int PKEY_FIPS_id(EVP_PKEY *pk, int *check,int *nid)
{
  int rv = 0;
  int tmp,tmp1;
  int id = 0;
  int tnid = 0;
  int size = 0;
  const EC_KEY *eck = NULL;
  const EC_GROUP *ecg = NULL;

  if(NULL == check) {
    check = &tmp;
  }
  *check = 0;
  if(NULL == nid) {
    nid = &tmp1;
  }
  *nid = 0;
  if (NULL != pk)
  {
    id = EVP_PKEY_id(pk);
    *nid = id;
    switch (id)
    {
    case 161: /* PBE2 */
      /* Now work out how to check the PBE params set */
      break;
    case 28: /* dhKeyAgreement */
      size = EVP_PKEY_bits(pk);
      switch (size)
      {
      case 2048:
      case 3072:
      case 4096:
      case 6144:
      case 8192:
        rv = 1;
        break;
      default:
        break;
      }
      break;
    case 1126: /* ffdhe2048 */
    case 1127: /* ffdhe3072 */
    case 1128: /* ffdhe4096 */
    case 1129: /* ffdhe6144 */
    case 1130: /* ffdhe8192 */
      rv = 1;
      break;
      /* Note X*** can't do sign verify */
    case 1087: /* ED25519 */
    case 1088: /* ED448 */
      *check = 1;
      break;
    case 408: /* Generic EC which is what we'll hit*/
      eck = EVP_PKEY_get0_EC_KEY(pk);
      ecg = EC_KEY_get0_group(eck);
      tnid = EC_GROUP_get_curve_name(ecg);
      if(tnid > 0) {
        *nid = tnid;
      }
      switch (tnid)
      {
      case 713: /* secp224r1  P-224 */
      case 415: /* prime256v1 P-256 */
      case 715: /* secp384r1  P-384 */
      case 716: /* secp521r1  P-521 */
      case 726: /* sect233k1  K-233 */
      case 727: /* sect233r1  B-233 */
      case 729: /* sect283k1  K-283 */
      case 730: /* sect283r1  B-283 */
      case 731: /* sect409k1  K-409 */
      case 732: /* sect409r1  B-409 */
      case 733: /* sect571k1  K-571 */
      case 734: /* sect571r1  B-571 */
        rv = 1;
        *check = 1;
        break;
      default:
        break;
      }
      break;
    case 116: /* DSA */
      size = EVP_PKEY_bits(pk);
      if ((size >= 2048) && (size <= 4096)) {
        rv = 1;
        *check = 2; /* Can verify, but not sign */
      }      
      break;
    case 6:   /* rsaEncryption, as with EC we should hit this */
    case 19:  /* RSA */
    case 912: /* RSA PSS */
    case 919: /* RSA OAEP */
      size = EVP_PKEY_bits(pk);
      if ((size >= 2048) && (size <= 4096))
      {
        rv = 1;
        *check = 1;
      }
      break;
    default:
      break;
    }
  }
  return rv;
}
/* Generic keygen, trap so we can perform the FIPS key consistancy checks */
int my_EVP_PKEY_keygen(ICClib *pcb, EVP_PKEY_CTX *cctx, EVP_PKEY **pk)
{
  int rv = 0;
  int rc = 0;
  const EVP_MD *md = NULL;
  EVP_MD_CTX *md_ctx = NULL;
  EVP_PKEY *tpk = NULL;
  unsigned char *refsig = NULL;
  size_t siglen = 512;
  int check = 0;
  int fips = 0; /* FIPS allowed */
  static unsigned char in[32] = "01234567890abcdefghi01234567890";
  int inlen = 20;
  int nid = 0;

  RAND_seed(NULL,0); /* Reseed before keygen */
  rv = EVP_PKEY_keygen(cctx, pk);
  md = EVP_get_digestbyname("SHA-224");
  if ((pcb != NULL) && (pcb->flags & ICC_FIPS_FLAG))
  {
    if ((1 == rv) && (NULL != pk) )
    {
      fips = PKEY_FIPS_id(*pk,&check,&nid);
      if (1 == check)
      {
        md_ctx = EVP_MD_CTX_new();
        if (NULL != md_ctx)
        {
          refsig = ICC_Malloc(8192, __FILE__, __LINE__); /* Large enough for a 4K RSA signature, we won't hit this with anything larger */
          tpk = NULL;
          if (NULL != refsig)
          {
            rc = EVP_DigestSignInit(md_ctx, &cctx, md, NULL, *pk);
            if (1 == rc)
            {
              rc = EVP_DigestSign(md_ctx, refsig, &siglen, in,
                                  inlen);
            }
            if (NULL != tpk)
            {
              EVP_PKEY_free(tpk);
              tpk = NULL;
            }
            if (1 == rc)
            {
              rc = EVP_DigestVerifyInit(md_ctx, &cctx, md, NULL, *pk);
            }
            if (1 == rc)
            {
              rc = EVP_DigestVerify(md_ctx, refsig, siglen, in, inlen);
            }
            if (1 != rc)
            {
              if (NULL != *pk)
              {
                EVP_PKEY_free(*pk);
                *pk = NULL;
              }
              rv = -1;
            }
            ICC_Free(refsig);
          }
          EVP_MD_CTX_free(md_ctx);
        }
      }
    }
  }
  if(2 == check) {
    fips = 0; /* DSA */
  }
  if ((NULL != pcb->callback) && (NULL != *pk))
  {
    (*pcb->callback)("ICC_EVP_PKEY_keygen", nid, fips);
  }
  return rv;
}
int my_EVP_PKEY_sign_init(ICClib *pcb,EVP_PKEY_CTX *pctx)
{
  int rv = 0;
  int fips = 0;
  int nid = 0;
  int check = 0;
  EVP_PKEY *pk = NULL;

  rv = EVP_PKEY_sign_init(pctx);
  if((NULL != pcb->callback) && (1 == rv)) {
    pk =  EVP_PKEY_CTX_get0_pkey(pctx);
    if(NULL != pk) { 
      fips = PKEY_FIPS_id(pk,&check,&nid);
      (*pcb->callback)("ICC_EVP_PKEY_sign_init",nid,fips);
    }
  }
  return rv;
}
int my_EVP_PKEY_verify_init(ICClib *pcb,EVP_PKEY_CTX *pctx)
{
  int rv = 0;
  int fips = 0;
  int nid = 0;
  int check = 0;
  EVP_PKEY *pk = NULL;

  rv = EVP_PKEY_verify_init(pctx);
  if((NULL != pcb->callback) && (1 == rv)) {
    pk =  EVP_PKEY_CTX_get0_pkey(pctx);
    if(NULL != pk) {
      fips = PKEY_FIPS_id(pk,&check,&nid);
      (*pcb->callback)("ICC_EVP_PKEY_verify_init",nid,fips);
    }
  }
  return rv;
}

int my_EVP_DigestSignInit(ICClib *pcb,EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey)
{
  int rv = 0;
  int fips = 0;
  int hfips = 0;
  int check = 0;
  int nid = 0;
  int hnid = 0;

  rv = EVP_DigestSignInit(ctx,pctx,type, e, pkey);
  /* Now check the pkey and the digest for fips validity 
    We'll try to return the nid of the failed whatever in the fail case
  */
  if((NULL != pcb->callback) && (1 == rv)) {
    fips = PKEY_FIPS_id(pkey,&check,&nid);
    if(2 == check) {
      fips = 0;
    }
    if(NULL != type) {
      hnid = EVP_MD_type(type);
      hfips =  FIPS_MDbyNID(hnid);
    }
    if(!fips) {
      (*pcb->callback)("ICC_EVP_DigestSignInit",nid,0);
    } else if(!hfips && (0 != hnid)) {
      (*pcb->callback)("ICC_EVP_DigestSignInit",hnid,0); 
    } else {
      (*pcb->callback)("ICC_EVP_DigestSignInit",nid,1);
    }
  }
  return rv;
}
int my_EVP_DigestVerifyInit(ICClib *pcb,EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey)
{
  int rv = 0;
  int fips = 0;
  int hfips = 0;
  int check = 0;
  int nid = 0;
  int hnid = 0;

  rv = EVP_DigestVerifyInit(ctx,pctx,type, e,pkey);
  if((NULL != pcb->callback) && (1 == rv) ) {
    fips = PKEY_FIPS_id(pkey,&check,&nid);
    if(NULL != type) {  
      hnid = EVP_MD_type(type);
      hfips =  FIPS_MDbyNID(hnid);
    }
    if(!fips) {
      (*pcb->callback)("ICC_EVP_DigestVerifyInit",nid,0);
    } else if(!hfips && (0 != hnid)) {
      (*pcb->callback)("ICC_EVP_DigestVerifyInit",hnid,0); 
    } else {
      (*pcb->callback)("ICC_EVP_DigestVerifyInit",nid,1);
    }
  }
  return rv;
}

int my_SP800_38F_KW(ICClib *pcb,unsigned char *in, int inl, unsigned char *out, int *outl, unsigned char *key, int kl,unsigned int flags) 
{
  int rv = 0;
  int nid = 0;
  int fips = 0;
  rv = SP800_38F_KW(in, inl, out, outl, key, kl,flags);
  if(pcb->callback) {
    switch (kl)
    {
    case 16:
    case 128:
      fips = 1;
      nid = 418;
      break;
    case 24:
    case 192:
      fips = 1;
      nid = 422;
      break;
    case 32:
    case 256:
      fips = 1;
      nid = 426;
      break;
    default:
      break;
    }
    (*pcb->callback)("ICC_SP800_38F_KW",nid,fips);
  }
  return rv;
}

int my_EVP_PKEY_derive_init(ICClib *pcb,EVP_PKEY_CTX *ctx)
{
  int rv = 0;
  int fips = 0; 
  int nid = 0;
  int check = 0;
  EVP_PKEY *pkey = NULL;
  rv = EVP_PKEY_derive_init(ctx);
  if((NULL != pcb->callback) && (1 == rv) ) {
    pkey = EVP_PKEY_CTX_get0_pkey(ctx);
    if(NULL != pkey) {
      fips = PKEY_FIPS_id(pkey,&check,&nid);
      (*pcb->callback)("ICC_EVP_derive_init",nid,fips);
    }
  } 
  return rv;
}
int my_RSA_sign(ICClib *pcb,int nid, const unsigned char *dgst, int dlen, unsigned char *sig, unsigned int *siglen, RSA *rsa)
{
  int rv = 0;
  int fips = 0; 
  int len = 0;

  rv = RSA_sign(nid,dgst, dlen, sig, siglen,rsa);
  if((NULL != pcb->callback) && (1 == rv)) {
    len = RSA_size(rsa);
    if(len >= 256 && len <= 512) { /* Key length is plausible, 2k->4k */
      fips = 1;
    }
    (*pcb->callback)("ICC_RSA_sign",19,fips);
  }
  return rv;
}
int my_RSA_verify(ICClib *pcb,int nid, const unsigned char *dgst, int dgst_len, const unsigned char *sigbuf, int siglen, RSA *rsa)
{
  int rv = 0;
  int fips = 0; 
  int len = 0;

  rv = RSA_verify(nid,dgst, dgst_len, sigbuf, siglen, rsa);
  if((NULL != pcb->callback) && (1 == rv)) {
    len = RSA_size(rsa);
    if(len >= 256 && len <= 512) { /* Key length is plausible */
      fips = 1;
    }
    (*pcb->callback)("ICC_RSA_verify",19,fips);
  }
  return rv;
}

int my_RSA_public_encrypt(ICClib *pcb,int flen, unsigned char *from,unsigned char *to, RSA *rsa,int padding)
{
  int rv = 0;
  int fips = 0;
  int len = 0;
  int cklen = 0;

  if(NULL != rsa) {
    len = RSA_size(rsa);
  }
  cklen = len;
  if(len > flen) {
    cklen = flen;
  }
  rv = RSA_public_encrypt(flen,from,to,rsa,padding);
  if(1 == rv) {
    if(0 == memcmp(from,to,cklen)) { /* Output unmodified , fail */
      rv = -1;
   }
  }
  if((NULL != pcb->callback) && (1 == rv)) {

     if(len >= 256 && len <= 512) { /* Key length is plausible */
      fips = 1;
    }
    (*pcb->callback)("ICC_RSA_public_encrypt",19,fips);
  }
  return rv;
}


int my_RSA_private_decrypt(ICClib *pcb,int flen, const unsigned char *from,unsigned char *to, RSA *rsa,int padding)
{
  int rv = 0;
  int fips = 0;
  int len = 0;
  int cklen = 0;

  if(NULL != rsa) {
    len = RSA_size(rsa);
  }
  cklen = len;
  if(len > flen) {
    cklen = flen;
  }
  rv = RSA_private_decrypt(flen,from,to,rsa,padding);
  if(1 == rv) {
    if(0 == memcmp(from,to,cklen)) { /* Output unmodified , fail */
      rv = -1;
    }
  }
  if((NULL != pcb->callback) && (1 == rv)) {

     if(len >= 256 && len <= 512) { /* Key length is plausible */
      fips = 1;
    }
    (*pcb->callback)("ICC_RSA_private_decrypt",19,fips);
  }
  return rv;
}


int my_RSA_public_decrypt(ICClib *pcb,int flen, unsigned char *from,unsigned char *to, RSA *rsa,int padding)
{
  int rv = 0;
  int fips = 0;
  int len = 0;
  int cklen = 0;

  if(NULL != rsa) {
    len = RSA_size(rsa);
  }
  cklen = len;
  if(len > flen) {
    cklen = flen;
  }
  rv = RSA_public_decrypt(flen,from,to,rsa,padding);
  if( 1 == rv) {
    if(0 == memcmp(from,to,cklen)) { /* Output unmodified , fail */
      rv = -1;
    }
  }
  if((NULL != pcb->callback) && (1 == rv)) {

     if(len >= 256 && len <= 512) { /* Key length is plausible */
      fips = 1;
    }
    (*pcb->callback)("ICC_RSA_public_decrypt",19,fips);
  }
  return rv;
}


int my_RSA_private_encrypt(ICClib *pcb,int flen, const unsigned char *from,unsigned char *to, RSA *rsa,int padding)
{
  int rv = 0;
  int fips = 0;
  int len = 0;
  int cklen = 0;

  if(NULL != rsa) {
    len = RSA_size(rsa);
  }
  cklen = len;
  if(len > flen) {
    cklen = flen;
  }
  rv = RSA_private_encrypt(flen,from,to,rsa,padding);
  if(1 == rv) {
    if(0 == memcmp(from,to,cklen)) { /* Output unmodified , fail */
      rv = -1;
    }
  }
  if((NULL != pcb->callback) && (1 == rv)) {

     if(len >= 256 && len <= 512) { /* Key length is plausible */
      fips = 1;
    }
    (*pcb->callback)("ICC_RSA_private_encrypt",19,fips);
  }
  return rv;
}

int my_PKCS5_PBKDF2_HMAC(ICClib *pcb,const char *pass, int passlen, const unsigned char *salt, int saltlen, int iters, const EVP_MD *digest, int keylen, unsigned char *out)
{
  int rv = 0;
  int fips = 0; 
  int nid = 0;
  rv = PKCS5_PBKDF2_HMAC(pass, passlen,salt, saltlen, iters, digest, keylen, out);
  if((pcb->callback) && (1 == rv)) {
    nid = EVP_MD_type(digest);
    fips = FIPS_MDbyNID(nid);
    if( 1 == fips) {
      if((saltlen < 16) ||  (iters < 1000) || (keylen < 14) || (passlen < 10) ){
        fips = 0;
      }      
    }
    (*pcb->callback)("ICC_PKCS5_PBKDF2_HMAC",nid,fips);
  }
  return rv;
}

int my_DH_generate_key(ICClib *pcb,DH *dh)
{
  int rv = 0;
  int len = 0;
  int fips = 0;
  RAND_seed(NULL,0); /* Reseed before keygen */
  rv = DH_generate_key(dh);
  if((pcb->callback) && (1 == rv) ) {
    len = DH_size(dh);
    if (len >= 256 && len <= 1024)
    {
      fips = 1;
    }
    if (1 == rv)
    {
      (*pcb->callback)("ICC_DH_generate_key", 0, fips);
    }
  }
  return rv; 
}

int my_DH_compute_key(ICClib *pcb,unsigned char *key,BIGNUM *pub_key,DH *dh)
{
  int nid = 1039;
  int rv = 0; 
  int len = 0;   
  int fips = 0;
  rv = DH_compute_key(key,pub_key,dh);
  if((pcb->callback) && (1 == rv) ) { 
    len = DH_size(dh);
    if (len >= 256 && len <= 1024)
    {
      fips = 1;
    }
    if (1 == rv)
    {
      (*pcb->callback)("ICC_DH_compute_key",nid, fips);
    }
  }
  return rv;
}
int my_DH_compute_key_padded(ICClib *pcb,unsigned char *key,BIGNUM *pub_key,DH *dh)
{
  int nid = 1039;
  int rv = 0; 
  int len = 0;   
  int fips = 0;
  rv = DH_compute_key_padded(key,pub_key,dh);
  if((pcb->callback) && (1 == rv) ) { 
    len = DH_size(dh);
    if (len >= 256 && len <= 1024)
    {
      fips = 1;
    }
    if (1 == rv)
    {
      (*pcb->callback)("ICC_DH_compute_key_padded",nid, fips);
    }
  }
  return rv;
}


#define HKDF_MAXBUF 1024

unsigned char *HKDF_Extract(ICClib *pcb,const EVP_MD *evp_md,
			    const unsigned char *salt, size_t salt_len,
			    const unsigned char *key, size_t key_len,
			    unsigned char *prk, size_t *prk_len)
{
    unsigned int tmp_len = 0;
    HMAC_CTX *hmac = NULL;
    hmac = HMAC_CTX_new();
    HMAC_Init(hmac,salt, (int)salt_len, evp_md);
    HMAC_Update(hmac,key,key_len);
    HMAC_Final(hmac,prk,&tmp_len);
    HMAC_CTX_free(hmac);
    *prk_len = tmp_len; 
    return prk;
}

unsigned char *HKDF_Expand(ICClib *pcb,const EVP_MD *evp_md,
			   const unsigned char *prk, size_t prk_len,
			   const unsigned char *info, size_t info_len,
			   unsigned char *okm, size_t okm_len)
{
  HMAC_CTX *hmac = NULL;
  unsigned int i;
  int fips = 0;
  int nid = -1;
  unsigned char prev[ICC_EVP_MAX_MD_SIZE];
  size_t done_len = 0;
  size_t dig_len = 0;  
  size_t n = 0; 
  size_t copy_len;
  unsigned char ctr;

  dig_len = EVP_MD_size(evp_md);
  n = okm_len / dig_len;
  nid = EVP_MD_type(evp_md);
  fips = FIPS_MDbyNID(nid);

  if (okm_len % dig_len)
    n++;

  if (n > 255 || okm == NULL)
    goto err;

  if ((hmac = HMAC_CTX_new()) == NULL)
    return NULL;

  if (!HMAC_Init(hmac, prk, (int)prk_len, evp_md))
    goto err;

  for (i = 1; i <= n; i++)
  {

    ctr = (unsigned char)i;

    if (i > 1)
    {
      if (!HMAC_Init(hmac, NULL, 0, NULL))
        goto err;

      if (!HMAC_Update(hmac, prev, dig_len))
        goto err;
    }

    if (!HMAC_Update(hmac, info, info_len))
      goto err;

    if (!HMAC_Update(hmac, &ctr, 1))
      goto err;

    if (!HMAC_Final(hmac, prev, NULL))
      goto err;

    copy_len = (done_len + dig_len > okm_len) ? okm_len - done_len : dig_len;

    memcpy(okm + done_len, prev, copy_len);

    done_len += copy_len;
  }

  HMAC_CTX_free(hmac);
  if((NULL != pcb) && (NULL != pcb->callback)) {
    (*pcb->callback)("ICC_HKDF_Expand",nid,fips);
  }
  return okm;

err:
  if(NULL != hmac) {
    HMAC_CTX_free(hmac);
  }
  return NULL;
}

unsigned char *HKDF(ICClib *pcb,const EVP_MD *evp_md,
			const unsigned char *salt, size_t salt_len,
			const unsigned char *key, size_t key_len,
			const unsigned char *info, size_t info_len,
			unsigned char *okm, size_t okm_len)
{
  unsigned char prk[ICC_EVP_MAX_MD_SIZE];
  unsigned char *ret = NULL;
  size_t prk_len = 0;
  
  if (!HKDF_Extract(pcb,evp_md, salt, salt_len, key, key_len, prk, &prk_len))
    return NULL;

  ret = HKDF_Expand(pcb,evp_md, prk, prk_len, info, info_len, okm, okm_len);
  memset(prk,0,sizeof(prk));
	 
  return ret;
}
/* Copied from OpenSSL-FIPS */
int dsa_paramgen_check_g(DSA *dsa)
{
    BN_CTX *ctx = NULL;
    BIGNUM *tmp = NULL;
    BN_MONT_CTX *mont = NULL;
    int rv = -1;
    ctx = BN_CTX_new();
    if (!ctx)
        return -1;
    BN_CTX_start(ctx);
    if (BN_cmp(dsa->g, BN_value_one()) <= 0)
        return 0;
    if (BN_cmp(dsa->g, dsa->p) >= 0)
        return 0;
    tmp = BN_CTX_get(ctx);
    if (!tmp)
        goto err;
    if ((mont = BN_MONT_CTX_new()) == NULL)
        goto err;
    if (!BN_MONT_CTX_set(mont, dsa->p, ctx))
        goto err;
    /* Work out g^q mod p */
    if (!BN_mod_exp_mont(tmp, dsa->g, dsa->q, dsa->p, ctx, mont))
        goto err;
    if (!BN_cmp(tmp, BN_value_one()))
        rv = 1;
    else
        rv = 0;
 err:
    BN_CTX_end(ctx);
    if (mont) {
        BN_MONT_CTX_free(mont);
    }
    BN_CTX_free(ctx);
    return rv;
}

#ifndef NUMITEMS
#define NUMITEMS(x) (sizeof(x)/sizeof((x)[0]))
#endif

/*
* Ref: https://www.di-mgt.com.au/rsa_factorize_n.html
Input: N, e, d.
Output: p and q where pq=N.
1. [Initialize] Set k=de?1.
2. [Try a random g] Choose g at random from {2,...,N?1} and set t=k.
3. [Next t] If t is divisible by 2, set t=t/2 and x=g^t mod N. Otherwise go to step 2.
4. [Finished?] If x>1 and y=gcd(x?1,N)>1 then set p=y and q=N/y, output (p,q) and terminate the algorithm. Otherwise go to step 3.
*/
static
void recalculateCRT(RSA* rsa)
{
   static const unsigned int gs[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };
   size_t gi = 0;
   BIGNUM* two;
   BIGNUM* g;
   BIGNUM* k;
   BIGNUM* t;
   BIGNUM* dv;
   BIGNUM* rem;
   BIGNUM* x;
   BIGNUM* y;
   BIGNUM * r1 = NULL, * r2 = NULL;
   BN_CTX* ctx = NULL;
   ctx = BN_CTX_new();
   if (ctx == NULL)
      goto err;
   BN_CTX_start(ctx);
   two = BN_new();
   BN_set_word(two, 2);
   g = BN_new();
   k = BN_secure_new();
   t = BN_secure_new();
   dv = BN_secure_new();
   rem = BN_secure_new();
   x = BN_secure_new();
   y = BN_secure_new();
   r1 = BN_CTX_get(ctx);
   r2 = BN_CTX_get(ctx);
   /* 1. [Initialize] Set k=d*e?1. */
   BN_mul(k, rsa->e, rsa->d, ctx);
   BN_sub_word(k, 1);
   /* 2. [Try a random g] Choose g at random from {2,...,N?1} and set t=k. */
   /* we actually choose g from a table of first primes < 100 */
   for (gi = 0; gi < NUMITEMS(gs); gi++) {
      BN_set_word(g, gs[gi]);
      if (BN_copy(t, k) == NULL) {
         break;
      }
      for (;;) {
         /* 3. [Next t] If t is divisible by 2, set t=t/2 and x=g^t mod N. Otherwise go to step 2. */
         BN_div(dv, rem, t, two, ctx);
         if (BN_is_zero(rem)) {
            if (BN_copy(t, dv) == NULL) {
               break;
            }
         }
         else {
            /* not divisible by 2 - goto step 2.*/
            break;
         }
         /*x*/
         BN_mod_exp(x, g, t, rsa->n, ctx);
         if (BN_is_one(x)) {
            /* goto step 3 */
            continue;
         }
         /*y=gcd(x?1,N)>1*/
         BN_sub_word(x, 1);
         BN_gcd(y, x, rsa->n, ctx);
         if (BN_is_one(y)) {
            /* goto step 3 */
            continue;
         }

         /* finished */
         if (BN_copy(rsa->p, y) == NULL) {
            break;
         }
         BN_div(rsa->q, NULL, rsa->n, rsa->p, ctx);
         if (BN_cmp(rsa->p, rsa->q) < 0) {
            /* swap p & q so p > q */
            BIGNUM * t = rsa->p;
            rsa->p = rsa->q;
            rsa->q = t;
         }
         {
            if (!BN_sub(r1, rsa->p, BN_value_one()))
               goto err;               /* p-1 */
            if (!BN_sub(r2, rsa->q, BN_value_one()))
               goto err;               /* q-1 */
            if (/* calculate d mod (p-1) */
               !BN_mod(rsa->dmp1, rsa->d, r1, ctx)
               /* calculate d mod (q-1) */
               || !BN_mod(rsa->dmq1, rsa->d, r2, ctx)) {
               goto err;
            }
            /* calculate inverse of q mod p */
            if (!BN_mod_inverse(rsa->iqmp, rsa->q, rsa->p, ctx))
               goto err;
         }
         if (ctx != NULL) {
            BN_CTX_end(ctx);
            BN_CTX_free(ctx);
         }
         return;
      }
   }
err:
   if (ctx != NULL) {
      BN_CTX_end(ctx);
      BN_CTX_free(ctx);
   }
   return;
   /* failed - give up - no more 'gs' to try, can actually try g (prime) < N */
}

static
int RSA_MergePubPri(RSA* rsaPri, const RSA* rsaPub)
{
   int rc = 0;
   int ebitSize = 0;
   ebitSize = BN_num_bits(rsaPri->e);
   if (ebitSize) {
      /* already have public exponent */
      return rc;
   }
   if (!rsaPub) {
      /* no public key supplied */
      return 2;
   }
   if (BN_cmp(rsaPri->n, rsaPub->n)) {
      /* no pub / pri key mismatch */
      return 1;
   }
   /* merge public exponent into private key */
   BN_copy(rsaPri->e, rsaPub->e);
   return rc;
}

/*
** RSA private key should have CRT components but may not.
** Fix the private keys so missing CRT will still work with just mod/exp
** 'pub' == NULL triggers CRT component removal if any zeros
** 'pub' non zero supplies 'e' for CRT recalculation.
*/
int RSA_FixEncodingZeros(RSA* rsa, const RSA* pub, int allowDisableBlinding)
{
   /* see if CRT components are zero and should be deleted */
   /* check them all - any zero means all have to go */
   /* also check if fixed already - nulls */
   int ebitSize = 0;
   int bitSize = rsa->dmp1 ? BN_num_bits(rsa->dmp1) : 1;
   if (bitSize) bitSize = rsa->dmq1 ? BN_num_bits(rsa->dmq1) : 1;
   if (bitSize) bitSize = rsa->iqmp ? BN_num_bits(rsa->iqmp) : 1;
   if (bitSize == 0) {
      /* fixup is required */
      RSA_MergePubPri(rsa, pub);
      ebitSize = BN_num_bits(rsa->e);
      if (ebitSize == 0) {
         /* this flag triggers code that requires 'e' so switch it off */
         rsa->flags &= ~RSA_FLAG_CACHE_PUBLIC;
         /* delete zero all CRT components */
         BN_clear_free(rsa->e);
         rsa->e = NULL;
         BN_clear_free(rsa->p);
         rsa->p = NULL;
         BN_clear_free(rsa->q);
         rsa->q = NULL;
         BN_clear_free(rsa->dmp1);
         rsa->dmp1 = NULL;
         BN_clear_free(rsa->dmq1);
         rsa->dmq1 = NULL;
         BN_clear_free(rsa->iqmp);
         rsa->iqmp = NULL;
      }
      else {
         /* recaculate the CRT components */
         recalculateCRT(rsa);
      }
   }
   return ICC_OSSL_SUCCESS;
}

/* A noop these days */
void my_GHASH(AES_GCM_CTX *gcm_ctx,unsigned char *H,unsigned char *Hash,unsigned char *data,unsigned long datalen)
{

}
#define MyCalloc(x,y) ICC_Calloc(x,y,__FILE__,__LINE__)
#define MyFree(x) ICC_Free(x)

#include "loaded.c" /* Self location code */
#if defined(STANDALONE_ICCLIB)
int check_status( ICC_STATUS *status, const char *file, int line )              
  
{                              
  const char *sev = "UNKNOWN ERROR TYPE";
  int rv = ICC_OK;

  if((status->majRC) != ICC_OK) {
    switch(status->majRC) {
    case ICC_ERROR:
      sev = "ICC_ERROR";
      break;
    case ICC_WARNING:
      sev = "ICC_WARNING";  
      break;
    case ICC_FAILURE:
      sev = "ICC_FAILURE";  
      break;
    case ICC_OPENSSL_ERROR:
      sev = "ICC_OPENSSL_ERROR";
      break;
    case ICC_OS_ERROR:
      sev = "ICC_OS_ERROR";
      break;
    default:
      rv = ICC_ERROR;
      break;
    }
    switch(status->majRC) {
    case ICC_ERROR:
    case ICC_FAILURE:
    case ICC_WARNING:
    case ICC_OPENSSL_ERROR:
    case ICC_OS_ERROR:  
      printf("Line %d: Status Check (%s): majRC: %d minRC: %d Error string: %s\n",line, sev,status->majRC, status->minRC , status->desc);
      rv = status->majRC;
      break;
    default:
      printf("Line %d: Status Check (%s): majRC: %d minRC: %d  \"Something bad happened\"\n",line,sev,status->majRC,status->minRC);
      break;
    }
  }

  return rv;
}




int main(int argc,char *argv[])
{
  int rc = 1;
  static int me = 0;
  double c2t = 0.0;
  ICC_STATUS status;
  if(!Global.initialized) {
    me = 1;
    rc = ICCLoad();
    if(0 != rc) printf("Self test failed\n");
  }
  check_status(&Global.status,__FILE__,__LINE__);
  if(me) {
    ICCUnload();
  }

  d[6] = Delta_T(0,&d[0]);

  c2t = Delta2Time(1);
  c2t /= 1000000000.0;
  printf("Find paths   %g\nRead conf    %g\nInit OpenSSL %g\nSelf Test    %g\nSig Check    %g\n main()      %g\n",c2t * d[1],c2t * d[2],c2t *d[3],c2t *d[4] ,c2t *d[5], c2t*d[6]);
  /* Added 2021 because we can hit different paths here */
  SetStatusOK(NULL,&status);
  SelfTest(NULL,&status);
  return me;
}

#endif
