/*************************************************************************
// Copyright IBM Corp. 2023
//
// Licensed under the Apache License 2.0 (the "License").  You may not use
// this file except in compliance with the License.  You can obtain a copy
// in the file LICENSE in the source distribution.
*************************************************************************/

/*************************************************************************
// Description: Low level algorithms used in heath tests.
//
*************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if !defined(STANDALONE)
#include "platform.h"
#endif
#include "TRNG/nist_algs.h"
#include "induced.h"
#if defined(TEST_DOUBLE)
#   include <math.h>
#endif



#if 0
static const char *APTag = "APtest";
static const char *RCTag = "RCTest";
static const char *PMAXTag = "PMAX";
static const char * PMAXB_Tag = "pmaxB";

#endif

static const char * HTtag = "ENTROPY_HT";
extern int ex_loops;    /* loops set from config file or environment */

/*! @brief delay loop
    @param i pointer to the loop iterator
    @param j pointer to the loop count
    @return total, just so that this appears to do something
*/
#if defined(_WIN32)
#  pragma optimize("",off)
#endif
int looper(volatile int *i,volatile int *j)
{
  int k = 0;
  for( ; (*i) < (*j); (*i)++ ) k++;
  return k;
}
#if defined(_WIN32)
#  pragma optimize("",on)
#endif

/* Converts the log values to % entropy * 2, results are scaled/truncated by the API */
static const unsigned int etabB[9] = {0,25,50,75,100,125,150,175,200};
/*
  Ref:http://graphics.stanford.edu/~seander/bithacks.html
  Public domain.
  IBM legal approval obtained to use the algorithm
*/	


/*! 
  @brief integer log2 of a 32 bit int
  @param v value to find the log of
  @return the log of v
*/
static unsigned int ilog2(unsigned int v)
{

  static const unsigned int b[] = {0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000};
  static const unsigned int S[] = {1, 2, 4, 8, 16};
  int i;
  
  unsigned int r = 0; 
  for (i = 4; i >= 0; i--) {
    
    if (v & b[i]) {
      v >>= S[i];
      r |= S[i];
    } 
  }
  return r;
}
/*!
  @brief Entropy estimate based on Appendix C.3 SP800-90
  Returns entropic bits out/200 bits in
  This variant works on bytes and is a lot more efficient in terms
  of processing time

  @param data pointer to the data buffer
  @param len number of bytes
  @return Entropy estimate (% * 2) i.e. 0 -200
*/



unsigned int pmaxLGetEnt(unsigned char *data, int len)
{
#if defined(TEST_DOUBLE)
  double p = 0.0, log2p = 0.0;
  double hmin = 0.0;
#endif
  int i = 0;
  int k = 0;
  int ip = 0;
  int ilog2p = 0;
  unsigned int syms[256];
  unsigned int est = 0;


  if (len >= 512)
  {
    memset(syms, 0, sizeof(syms));

    for (i = 0; i < len; i++)
    {
      syms[data[i]]++;
    }
    k = 0;
    for (i = 0; i < 256; i++)
    {
      if (syms[i] > k)
      {
        k = syms[i];
      }
    }

    /* 
       Convert the most common value to a probability
       Integer version we work in inverse space to keep the numbers
       > 1
  */
    ip = len / k;
    ilog2p = ilog2(ip);
    /*
      Our estimate is for 8 bits
      Convert to how many bits we need to guarantee 100 bits of entropy
      Note we have 512 samples
      The maximum samples we could have/bucket is 512 (no entropy)
      minimum and evenly distributed is 2 (max entropy)
      Table lookup here because it's simpler.
     */
    est = etabB[ilog2p];

#if defined(TEST_DOUBLE)
    printf("k = %d ", k);
    p = (double)k / (double)(e->nsam);
    log2p = -log2(p);
    printf("float %f int %d\n", log2p, est);
#endif
  }
  return est;
}


/*!@brief
  Health test for the incoming noise
  @param HT a pointer to the Health Test Object
  @param data data buffer
  @return 0 if O.K. 1 if the tests will fail with the current sample.
  @note no min-entropy test, if that's wanted it's done elsewhere
  this just performs the AP and RC tests on E_ESTB_BUFLEN bytes
  at the target entropy
*/

int ht(ENTROPY_HT *HT, unsigned char data[E_ESTB_BUFLEN])
{
  int htfail = 0;

  if(APtestBK(HT->H,data)) {
    htfail |= 2;
  }
  if(RCtestBK(HT->H,data)) {
    htfail |= 4;
  }

  return htfail;
}

/*! @brief Initialize a TRNG health test structure, setting it up
  for the appropriate entropy guarantees
  @param E a pointer to the entropy health test data structure
  @param H the desired entropy guarantee as a % in 8 bits
  i.e. 25,50,75. 0,100 are in practice unusable options
  @return 1 on sucess, 0 on failure
*/
int ht_Init(ENTROPY_HT *E, int H)
{  
  int rv = 1;
  E->H = H;
  E->e = 0;
  E->id = HTtag;
  return rv;
}


/*!
  @brief Continuous entropy estimate based on Appendix C.3 SP800-90
  Returns entropic bits out/100 bits in over a 4 bit space
  Very coarse approx.i.e. 0:0-24,25:25-49,50:50-74,75:75-99,100:100 and is conservative.
  And yes there are five values reported. Log functions :{
  @param data data in
  @param len length of data (min 32 bytes)
  @note returns 0 if too little data is provided
*/


int pmax4(unsigned char *data,int len)
{
  static const int etab[5] = {0,25,50,75,100};
  int i = 0;
  int k = 0;
  unsigned short syms[16];
  int ip = 0;
  int ilog2p = 0;
  int iest = 0; /* We trip a fail if we don't have enough data (32 bytes min) */
#if defined(TEST_DOUBLE)
  double p = 0.0,log2p =0.0;
  double hmin = 0.0;	
#endif


  /* Rolling entropy estimate
     once we wrap around, we start pulling out the last
     value and removing it's stats after inserting the new
  */    
 if(len >= 32) {
   memset(syms,0,sizeof(syms));
   for(i = 0; i < len; i++) {
    /* Insert the new symbol into the circular buffer, update stats */
    syms[(data[i] & 0x0f)]++; 
    syms[((data[i] >> 4) & 0x0f)]++;
   }          	
    k = 0;
    for(i = 0; i < 16; i++) {
      if(syms[i] > k) {
	      k = syms[i];
      }	
    }
    /* 
       Convert the most common value to a probability
       Integer version we work in inverse space to keep the numbers
       > 1
    */
    ip = (len * 2)/(k);
    ilog2p = ilog2(ip);
    /*
      Our estimate is for 4 bits
      Convert to how many bits we need to guarantee 100 bits of entropy
      Note we have 128 samples
      The maximum samples we could have/bucket is 128 (no entropy)
      minimum and evenly distributed is 8 (max entropy)
      Table lookup here because it's simpler.
     */
    iest = etab[ilog2p];

#if defined(TEST_DOUBLE)
    printf("k = %d ",k);
    p = (double)k / (len * 2);
    log2p = -log2(p);	  
    printf("float %f int %d\n",log2p,iest);
#endif
  }

  return iest;
}




/*!
  Block orientated version of APTest 
  @param N the entropy required (%) 0 -100 
  @param bk the data block to be checked, must be 512 bytes
  @return 0 if above required entropy, 1 otherwise
  */
int APtestBK(int N, unsigned char data[512])
{
  int rv = 0; 
  unsigned int cnt[256];
  static int h[5] = {311,177,62,23,13};
  int C = 0;
  int i = 0;
  int maxc = 0;
  unsigned char t;

  /* Check that N is one of the allowed values 12,25,50,75,100
     pick the appropriate table
   */


  switch(N) {
  case 12: /* 12.5 which we can't represent and don't use*/
  case 13:
    C = h[0];
    break;
  case 25:
    C = h[1];
    break;
  case 50:
    C = h[2];
    break;
  case 75:
    C = h[3]; /* Guess , unused */
    break;
  case 100:
    C = h[4];  
  default:
    C = 0; /* Estimator wil fail */
    break;
  }
  memset(cnt,0,sizeof(cnt));
  for(i = 0; i < E_ESTB_BUFLEN; i++) {
    t = data[i];
    cnt[t]++;
  }

  for(i = 0; i < 256; i++)
  {
    if(cnt[i] > maxc) {
      maxc = cnt[i];
    }
  }
  /* printf("C = %d, maxc = %d\n",C,maxc); */

  if (maxc >= C)
  {
    rv = 1;
  }

  return rv;
}

int RCtestBK(int H,unsigned char bk[512])
{
  static int RCTable[3] = {16,9,6};
  int rv = 0;
  int Hi;
  int limit;
  int B = 0;
  int i;
  int c = -1;

  switch (H)
  {
  case 25:
  case 50:
  case 75:
    Hi = (H / 25) - 1;
    limit = RCTable[Hi];
    break;
  default:
    rv = 2;
    break;
  }
  if (0 == rv)
  {
    for (i = 0; i < 512; i++)
    {
      if (c == bk[i])
      {
        B++;
      }
      else
      {
        c = bk[i];
        B = 0;
      }
      if (B >= limit)
      {
        rv = 1;
        break;
      }
    }
  }
  return rv;
}



/**
  \known Data: failRC50 failing data for the Repeat Count tests

  Test vectors for the AP and RC tests
  "should pass" & should fail sets
  We test relatively small data sets, the test vector size is 
  a problem otherwise, these are present only as a sanity check on
  the algorithms so the use of small samples isn't a critical weakness.
 */
static unsigned char failRC50[512] = {
0x28,0x86,0xad,0xf3,0x58,0x3c,0xe7,0x95,
0x67,0xd5,0x8a,0x2c,0x90,0x84,0x17,0xb7,
0xe6,0x7a,0x1f,0x1e,0x76,0x80,0x38,0x91,
0x3c,0x8c,0x32,0xb1,0x76,0x74,0xf0,0xee,
0x3e,0xa3,0x4e,0x78,0x92,0x29,0x74,0xad,
0xf7,0xc6,0x9c,0xa9,0x5f,0x3f,0xfb,0x3d,
0x1f,0xe9,0xa9,0x00,0x3e,0xb5,0x85,0x62,
0x02,0x1f,0x56,0x83,0xf3,0x29,0xc6,0x37,
0x8c,0xc4,0xd5,0xbd,0xd2,0xed,0x41,0x32,
0xc8,0xd0,0xa8,0xf2,0x8c,0x03,0x73,0x9e,
0x56,0x9c,0x8f,0xa5,0x4e,0xce,0xfd,0x99,
0xce,0xab,0xf3,0x36,0xb1,0x53,0xdf,0x8a,
0x57,0x82,0x7d,0xae,0x45,0xef,0xc6,0x1a,
0x46,0x22,0x8b,0x9f,0x3f,0xfd,0x27,0x6f,
0x86,0x25,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,
0x6b,0x6b,0x6b,0x0b,0xff,0x84,0xbe,0xf6,
0x81,0x60,0xfa,0x8e,0x9e,0x0f,0x08,0x26,
0x71,0xc9,0xc5,0xb9,0x8e,0xb8,0xd3,0x6d,
0x79,0x83,0x65,0xe9,0x72,0x2c,0xe5,0xcf,
0xd4,0x12,0x73,0x48,0xfa,0x00,0xbe,0x59,
0x0c,0x8c,0x5f,0x70,0x39,0x68,0x0e,0xca,
0x12,0x01,0x22,0x76,0x2e,0xb7,0xcb,0x62,
0x10,0xb5,0x37,0x05,0xd4,0xd3,0xaf,0x28,
0x03,0x34,0xfa,0x37,0x13,0xe2,0x8d,0xba,
0x7d,0xb1,0xcd,0x9a,0xe2,0xc3,0x5a,0x88,
0x06,0x6e,0x31,0xa1,0x6c,0x03,0x05,0xb2,
0x42,0xf6,0xcd,0x7c,0xe1,0x26,0x65,0xd4,
0x41,0xe4,0x12,0x04,0x79,0xa0,0xb6,0x5b,
0x22,0x6c,0x3a,0x1c,0x2a,0x39,0xea,0x76,
0xbc,0x35,0x6a,0xe5,0x96,0x34,0x49,0x13,
0x72,0x8a,0xf5,0xbb,0x7a,0x8a,0x1c,0xca,
0xa8,0xfe,0x7f,0xc5,0x1e,0x26,0x38,0x72,
0x28,0x86,0xad,0xf3,0x58,0x3c,0xe7,0x95,
0x67,0xd5,0x8a,0x2c,0x90,0x84,0x17,0xb7,
0xe6,0x7a,0x1f,0x1e,0x76,0x80,0x38,0x91,
0x3c,0x8c,0x32,0xb1,0x76,0x74,0xf0,0xee,
0x3e,0xa3,0x4e,0x78,0x92,0x29,0x74,0xad,
0xf7,0xc6,0x9c,0xa9,0x5f,0x3f,0xfb,0x3d,
0x1f,0xe9,0xa9,0x00,0x3e,0xb5,0x85,0x62,
0x02,0x1f,0x56,0x83,0xf3,0x29,0xc6,0x37,
0x8c,0xc4,0xd5,0xbd,0xd2,0xed,0x41,0x32,
0xc8,0xd0,0xa8,0xf2,0x8c,0x03,0x73,0x9e,
0x56,0x9c,0x8f,0xa5,0x4e,0xce,0xfd,0x99,
0xce,0xab,0xf3,0x36,0xb1,0x53,0xdf,0x8a,
0x57,0x82,0x7d,0xae,0x45,0xef,0xc6,0x1a,
0x46,0x22,0x8b,0x9f,0x3f,0xfd,0x27,0x6f,
0x86,0x25,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,
0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,
0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,
0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,
0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,
0x71,0xc9,0x6b,0xb9,0x8e,0x6b,0xd3,0x6d,
0x79,0x83,0x6b,0xe9,0x72,0x6b,0xe5,0xcf,
0xd4,0x12,0x6b,0x48,0xfa,0x6b,0xbe,0x59,
0x0c,0x8c,0x6b,0x70,0x39,0x6b,0x0e,0xca,
0x12,0x01,0x6b,0x76,0x2e,0x6b,0xcb,0x62,
0x10,0xb5,0x6b,0x05,0xd4,0x6b,0xaf,0x28,
0x03,0x34,0x6b,0x37,0x13,0x6b,0x8d,0xba,
0x7d,0xb1,0x6b,0x9a,0xe2,0xc3,0x5a,0x88,
0x06,0x6e,0x31,0xa1,0x6c,0x03,0x05,0xb2,
0x42,0xf6,0xcd,0x7c,0xe1,0x6b,0x65,0xd4,
0x41,0xe4,0x12,0x04,0x79,0x6b,0xb6,0x5b,
0x22,0x6c,0x3a,0x1c,0x2a,0x6b,0xea,0x76,
0xbc,0x35,0x6a,0xe5,0x96,0x6b,0x49,0x13,

};
/**
  \known Data: Known good data for the Repeat Count,
  Adaptive Proportion and pmax algoritms tests

*/
static unsigned char good50[] = {
0x28,0x86,0xad,0xf3,0x58,0x3c,0xe7,0x95,
0x67,0xd5,0x8a,0x2c,0x90,0x84,0x17,0xb7,
0xe6,0x7a,0x1f,0x1e,0x76,0x80,0x38,0x91,
0x3c,0x8c,0x32,0xb1,0x76,0x74,0xf0,0xee,

0x3e,0xa3,0x4e,0x78,0x92,0x29,0x74,0xad,
0xf7,0xc6,0x9c,0xa9,0x5f,0x3f,0xfb,0x3d,
0x1f,0xe9,0xa9,0x00,0x3e,0xb5,0x85,0x62,
0x02,0x1f,0x56,0x83,0xf3,0x29,0xc6,0x37,

0x8c,0xc4,0xd5,0xbd,0xd2,0xed,0x41,0x32,
0xc8,0xd0,0xa8,0xf2,0x8c,0x03,0x73,0x9e,
0x56,0x9c,0x8f,0xa5,0x4e,0xce,0xfd,0x99,
0xce,0xab,0xf3,0x36,0xb1,0x53,0xdf,0x8a,

0x57,0x82,0x7d,0xae,0x45,0xef,0xc6,0x1a,
0x46,0x22,0x8b,0x9f,0x3f,0xfd,0x27,0x6f,
0x86,0x25,0x6b,0x98,0x4c,0x07,0x8a,0xf4,
0xb2,0xbf,0x0b,0x5b,0xff,0x84,0xbe,0xf6,

0x81,0x63,0xfa,0x8e,0x9e,0x2f,0x08,0x26,
0x71,0xc9,0xc5,0xb9,0x8e,0xb8,0xd3,0x6d,
0x79,0x83,0x65,0xe9,0x72,0x2c,0xe5,0xcf,
0xd4,0x12,0x73,0x48,0xfa,0x04,0xbe,0x59,

0x0c,0x8c,0x5f,0x70,0x39,0x68,0x0e,0xca,
0x12,0x01,0x22,0x76,0x2e,0xb7,0xcb,0x62,
0x10,0xb5,0x37,0x05,0xd4,0xd3,0xaf,0x28,
0x03,0x34,0xfa,0x37,0x13,0xe2,0x8d,0xba,
0x7d,0xb1,0xcd,0x9a,0xe2,0xc3,0x5a,0x88,
0x06,0x6e,0x31,0xa1,0x6c,0x03,0x05,0xb2,
0x42,0xf6,0xcd,0x7c,0xe1,0x26,0x65,0xd4,
0x41,0xe4,0x12,0x04,0x79,0xa0,0xb6,0x5b,
0x22,0x6c,0x3a,0x1c,0x2a,0x39,0xea,0x76,
0xbc,0x35,0x6a,0xe5,0x96,0x34,0x49,0x13,
0x72,0x8a,0xf5,0xbb,0x7a,0x8a,0x1c,0xca,
0xa8,0xfe,0x7f,0xc5,0x1e,0x26,0x38,0x72,

0x8f,0xff,0x3e,0x72,0x48,0xf3,0xd5,0xd3,
0x0c,0x63,0x76,0x52,0xb1,0xef,0xd1,0xe1,
0xaa,0x48,0xf4,0x32,0x6f,0x3f,0xb1,0x68,
0xb2,0xa1,0xb1,0x0e,0x68,0x5a,0xc9,0xaa,
0xf3,0xf2,0xba,0xfd,0xb7,0xfe,0x71,0x1c,
0x90,0x0a,0x06,0x58,0xde,0x05,0x7f,0x3e,
0x18,0x8d,0xbe,0x1a,0x6d,0x80,0xe2,0x38,
0xfe,0x5e,0x73,0x97,0x73,0xb4,0x74,0x7e,
0xe8,0x93,0xcb,0x18,0x3e,0xf4,0x3e,0x60,
0xca,0x4b,0x74,0x43,0x6c,0xe1,0x83,0xb5,
0x04,0x54,0xb8,0xbb,0xbb,0x69,0xba,0x69,
0x74,0xf9,0xd7,0x96,0x5d,0x4b,0xff,0xa8,
0x36,0x1e,0x0d,0x9b,0x6e,0xf5,0xf9,0xe3,
0x3a,0xbb,0xe2,0x92,0x1d,0x43,0xce,0x81,
0xb4,0x65,0x94,0xa9,0x3f,0xe3,0xef,0xcc,
0xc7,0x45,0x4e,0xb9,0xb3,0x24,0x80,0x2e,
0x92,0xc7,0xf3,0x79,0x73,0x8f,0xb8,0x82,0xeb,0xed,0x9a,0x7f,0x6f,0xdf,0x80,0xf4,
0x1a,0x94,0x4c,0xd8,0x0f,0xe1,0x78,0xad,0x6f,0xfa,0xde,0x99,0xea,0xa2,0x9c,0xdb,
0xa2,0x4f,0xa1,0x6d,0x5d,0xbd,0x94,0xc0,0x7f,0x2f,0x1e,0x32,0xe8,0x83,0x8b,0xfb,
0xd6,0x3e,0xd2,0xc8,0xf4,0x02,0x1f,0x4c,0xfc,0x97,0x99,0xaf,0xcd,0x5f,0xe3,0xd3,
0x9e,0x43,0x2a,0x01,0x6d,0x55,0x5b,0x00,0x4e,0x71,0xc9,0xbc,0x1c,0xc4,0xbb,0xc7,
0x9f,0xe9,0x81,0x90,0x6e,0x7f,0x95,0x4e,0xeb,0x5f,0xcc,0xac,0x28,0x0e,0x74,0x76,
0x02,0x95,0xaa,0xaa,0x6b,0x81,0x7a,0xba,0x86,0x16,0x0f,0xd4,0x03,0x79,0x88,0xd2,
0x72,0xbf,0x0f,0xae,0x11,0x82,0xfc,0x1e,0x17,0x68,0x26,0x6c,0xac,0x22,0x81,0xb3,
0x32,0x94,0x68,0x55,0x04,0xb8,0xd7,0x2d,0xc2,0x94,0x4c,0x46,0xc4,0x4a,0xe0,0x97,
0x0b,0xc6,0x9e,0x28,0xd8,0x69,0xa4,0x3f,0x91,0x06,0x8b,0x74,0x3b,0xa7,0xea,0x63,
0x8f,0x9e,0xb4,0xb5,0x93,0x4e,0xc7,0x3c,0x42,0x09,0xac,0xfb,0x41,0x12,0x32,0x21,
0xf0,0x08,0x42,0xbd,0xc3,0x7d,0x46,0x0d,0xd1,0x21,0x30,0x59,0x84,0xd6,0x56,0x6c,
0xf9,0x60,0xac,0x6b,0x13,0x4c,0x4a,0x8d,0xf5,0x22,0xe5,0xef,0x8b,0x31,0x35,0x8f,
0x3a,0x4d,0x15,0xf5,0xcf,0xf7,0xc7,0x59,0x2b,0xb0,0x9d,0xd9,0xc4,0x99,0xcb,0xd5,
0xc5,0x6f,0x49,0x1d,0x29,0xcc,0xac,0x32,0x3d,0xb4,0xf8,0x4e,0x61,0xef,0xd2,0x3f,
0x6c,0xe2,0x7a,0x5c,0xb3,0x4e,0x91,0x09,0x17,0xc5,0x6c,0x0e,0x15,0x4c,0xe3,0xf1,
0xbe,0xcb,0xd1,0x79,0x44,0x27,0xcb,0x2d,0x23,0xd7,0xee,0x57,0x21,0xe2,0xfe,0x26,
0x50,0x47,0x2f,0x1e,0xb2,0xc5,0x56,0x68,0xe2,0x7e,0xc3,0xaa,0xb1,0x38,0xc3,0xb4,
0xf9,0x3b,0x24,0x5d,0x5c,0x7a,0x73,0x84,0x2a,0x70,0x8e,0x8f,0xb1,0x59,0xf8,0x83,
0xf5,0x97,0x42,0x55,0x02,0xf6,0x95,0x59,0x6c,0x15,0x24,0x2b,0xc9,0xd9,0x66,0x2b,
0xa1,0xe5,0xec,0x1f,0x8a,0xb4,0x10,0xde,0xb0,0xe4,0x47,0x72,0x59,0x56,0x14,0xf8,
0x5b,0x06,0x25,0x74,0xe2,0xae,0xbe,0x4a,0x79,0x02,0x05,0x30,0x04,0xb2,0x6e,0x69,
0x81,0x56,0xdc,0xaf,0x6e,0x37,0x88,0x02,0x75,0x5a,0x1f,0xe7,0xe0,0xe5,0x4d,0xbe,
0xe7,0x38,0x78,0x5f,0xa3,0x17,0x85,0xa8,0x9d,0xae,0x9f,0xba,0xdb,0x58,0xa2,0xb1
};
/**
  \known Data: failAP50 Known bad data for Adaptive Proportion tests

*/
/* bad data*/
static unsigned char failAP50[] = {
0x28,0x86,0xad,0xf3,0xa5,0x3c,0xe7,0xa5,
0x67,0xa5,0x8a,0x2c,0x90,0x84,0x17,0xb7,
0xe6,0x7a,0x1f,0x1e,0x76,0x80,0x38,0x91,
0xa5,0x8c,0x32,0xb1,0x76,0x74,0xf0,0xa5,
0x3e,0xa5,0x4e,0x78,0x92,0x29,0x74,0xad,
0xf7,0xc6,0x9c,0xa9,0x5f,0x3f,0xfb,0x3d,
0x1f,0xe9,0xa9,0x00,0x3e,0xa5,0x85,0x62,
0x02,0x1f,0x56,0xa5,0xf3,0x29,0xc6,0x37,
0x8c,0xc4,0xd5,0xbd,0xd2,0xed,0x41,0x32,
0xc8,0xd0,0xa8,0xf2,0x8c,0x03,0x73,0x9e,
0xa5,0x9c,0x8f,0xa5,0x4e,0xce,0xfd,0x99,
0xce,0xa5,0xf3,0x36,0xb1,0x53,0xdf,0x8a,
0x57,0x82,0x7d,0xae,0xa5,0xef,0xc6,0x1a,
0x46,0x22,0x8b,0x9f,0x3f,0xfd,0x27,0xa5,
0x86,0x25,0x6b,0x98,0x4c,0x07,0x8a,0xf4,
0xb2,0xa5,0x0b,0xa5,0xff,0x84,0xbe,0xf6,
0x81,0x60,0xfa,0x8e,0x9e,0x0f,0x08,0x26,
0x71,0xc9,0xc5,0xb9,0x8e,0xb8,0xd3,0xa5,
0x79,0x83,0x65,0xe9,0x72,0x2c,0xe5,0xcf,
0xd4,0x12,0x73,0xa5,0xfa,0x00,0xbe,0x59,
0x0c,0x8c,0x5f,0x70,0xa5,0xa5,0x0e,0xca,
0x12,0x01,0x22,0x76,0x2e,0xb7,0xcb,0x62,
0x10,0xa5,0x37,0xa5,0xd4,0xd3,0xaf,0x28,
0xa5,0x34,0xfa,0x37,0x13,0xe2,0x8d,0xba,
0x7d,0xb1,0xcd,0xa5,0xe2,0xc3,0x5a,0xa5,
0x06,0x6e,0x31,0xa1,0xa5,0x03,0xa5,0xb2,
0x42,0xa5,0xcd,0x7c,0xe1,0x26,0xa5,0xa5,
0x41,0xe4,0x12,0x04,0x79,0xa5,0xa5,0x5b,
0x22,0x6c,0x3a,0xa5,0x2a,0x39,0xea,0x76,
0xbc,0xa5,0x6a,0xe5,0xa5,0x34,0xa5,0x13,
0x72,0x8a,0xf5,0xbb,0x7a,0x8a,0x1c,0xca,
0xa8,0xa5,0x7f,0xc5,0xa5,0x26,0xa5,0x72,

0x8f,0xff,0x3e,0x72,0x48,0xf3,0xd5,0xd3,
0x0c,0x63,0x76,0x72,0xb1,0xef,0xd1,0xe1,
0xaa,0x48,0xf4,0x72,0x6f,0x3f,0xb1,0x68,
0xb2,0xa1,0xb1,0x0e,0x68,0x5a,0xc9,0xaa,
0xf3,0x72,0xba,0xfd,0xb7,0xfe,0x71,0x1c,
0x90,0x0a,0x06,0x58,0xde,0x05,0x7f,0x3e,
0x18,0x8d,0xbe,0x1a,0x6d,0x80,0xe2,0x38,
0xfe,0x5e,0x72,0x97,0x72,0xb4,0x74,0x7e,
0xe8,0x93,0xcb,0x18,0x3e,0xf4,0x3e,0x60,
0xca,0x4b,0x74,0x43,0x6c,0xe1,0x83,0xb5,
0x04,0x54,0xb8,0xbb,0xbb,0x69,0xba,0x69,
0x72,0xf9,0xd7,0x96,0x5d,0x4b,0xff,0xa8,
0x36,0x1e,0x0d,0x9b,0x6e,0xf5,0xf9,0xe3,
0x3a,0xbb,0xe2,0x72,0x1d,0x43,0xce,0x81,
0xb4,0x65,0x94,0xa9,0x3f,0xe3,0xef,0xcc,
0xc7,0x45,0x4e,0xb9,0xb3,0x24,0x80,0x2e,
0x72,0x72,0xf3,0x72,0x72,0x8f,0xb8,0x72,0xeb,0xed,0x9a,0x7f,0x6f,0xdf,0x80,0xf4,
0x1a,0x94,0x4c,0xd8,0x0f,0xe1,0x72,0xad,0x6f,0xfa,0xde,0x99,0xea,0x72,0x9c,0xdb,
0xa2,0x4f,0xa1,0x6d,0x5d,0xbd,0x94,0xc0,0x72,0x2f,0x1e,0x72,0xe8,0x83,0x8b,0xfb,
0xd6,0x3e,0xd2,0xc8,0xf4,0x02,0x1f,0x4c,0xfc,0x97,0x99,0xaf,0xcd,0x5f,0xe3,0xd3,
0x9e,0x43,0x2a,0x01,0x6d,0x55,0x5b,0x00,0x4e,0x71,0xc9,0xbc,0x1c,0xc4,0xbb,0xc7,
0x9f,0xe9,0x81,0x90,0x6e,0x7f,0x95,0x4e,0xeb,0x5f,0xcc,0xac,0x28,0x0e,0x74,0x76,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x68,0x26,0x6c,0xac,0x22,0x81,0xb3,
0x32,0x94,0x68,0x55,0x04,0xb8,0xd7,0x2d,0xc2,0x94,0x4c,0x46,0xc4,0x4a,0xe0,0x97,
0x0b,0xc6,0x9e,0x28,0xd8,0x69,0xa4,0x3f,0x91,0x06,0x8b,0x74,0x3b,0xa7,0xea,0x63,
0x8f,0x9e,0xb4,0xb5,0x93,0x4e,0xc7,0x3c,0x42,0x09,0xac,0xfb,0x41,0x12,0x32,0x21,
0xf0,0x08,0x42,0xbd,0xc3,0x7d,0x46,0x0d,0xd1,0x21,0x30,0x59,0x84,0xd6,0x56,0x6c,
0xf9,0x60,0xac,0x6b,0x13,0x4c,0x4a,0x8d,0xf5,0x22,0xe5,0xef,0x8b,0x31,0x35,0x8f,
0x3a,0x4d,0x15,0xf5,0xcf,0xf7,0xc7,0x59,0x2b,0xb0,0x9d,0xd9,0xc4,0x99,0xcb,0xd5,
0xc5,0x6f,0x49,0x1d,0x29,0xcc,0xac,0x32,0x3d,0xb4,0xf8,0x4e,0x61,0xef,0xd2,0x3f,
0x6c,0xe2,0x7a,0x5c,0xb3,0x4e,0x91,0x09,0x17,0xc5,0x6c,0x0e,0x15,0x4c,0xe3,0xf1,
0xbe,0xcb,0xd1,0x79,0x44,0x27,0xcb,0x2d,0x23,0xd7,0xee,0x57,0x21,0xe2,0xfe,0x26,
0x50,0x47,0x2f,0x1e,0xb2,0xc5,0x56,0x68,0xe2,0x7e,0xc3,0xaa,0xb1,0x38,0xc3,0xb4,
0xf9,0x3b,0x24,0x5d,0x5c,0x7a,0x73,0x84,0x2a,0x70,0x8e,0x8f,0xb1,0x59,0xf8,0x83,
0xf5,0x97,0x42,0x55,0x02,0xf6,0x95,0x59,0x6c,0x15,0x24,0x2b,0xc9,0xd9,0x66,0x2b,
0xa1,0xe5,0xec,0x1f,0x8a,0xb4,0x10,0xde,0xb0,0xe4,0x47,0x72,0x59,0x56,0x14,0xf8,
0x5b,0x06,0x25,0x74,0xe2,0xae,0xbe,0x4a,0x79,0x02,0x05,0x30,0x04,0xb2,0x6e,0x69,
0x81,0x56,0xdc,0xaf,0x6e,0x37,0x88,0x02,0x75,0x5a,0x1f,0xe7,0xe0,0xe5,0x4d,0xbe,
0xe7,0x38,0x78,0x5f,0xa3,0x17,0x85,0xa8,0x9d,0xae,0x9f,0xba,0xdb,0x58,0xa2,0xb1
};
/**
  \known Data: badE Test data with falling entropy for the pmax
  algorithm

*/
static unsigned char badE[] = {
0xb2,0x49,0x85,0x6e,0xa8,0xe6,0xe2,0xd4,
0xf6,0xd1,0xab,0xdf,0x73,0x09,0xff,0xb1,
0x8b,0xfd,0x39,0x81,0x44,0x3c,0x32,0x9e,
0x6a,0x61,0xb1,0x37,0xf0,0x7a,0x86,0xd9, /* 32 */
0x73,0x0c,0x8b,0x4f,0xf1,0xde,0x62,0x05,
0xad,0x4a,0x25,0xe6,0xe9,0x35,0x21,0x2c,
0xb6,0x81,0xb7,0x14,0xe1,0x0e,0x60,0x05,
0x1e,0x4d,0x73,0x45,0xef,0xaa,0x56,0x6d, /* 64*/
0x73,0xe0,0x5e,0x11,0xe4,0x06,0xd3,0xae,
0xd2,0x30,0xd5,0x4d,0x47,0x9e,0x89,0x8e,
0x97,0x3f,0x19,0x05,0x57,0x39,0x75,0x73,
0x76,0xa3,0xe0,0x07,0x37,0xde,0xb3,0x91, /* 96 */
0x02,0x1f,0x02,0x1f,0x02,0x1f,0x02,0x1f,
0x02,0x1f,0x02,0x1f,0x02,0x1f,0x02,0x1f,
0x02,0x1f,0x02,0x1f,0x02,0x1f,0x02,0x1f,
0x02,0x1f,0x02,0x1f,0x02,0x1f,0x02,0x1f, /* 128 */
0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,
0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22, /* 160 */
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02, /* 192 */
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02, 
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02, /* 256 */
0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x02,0x1f,0x02,0x1f,0x02,0x1f,0x02,0x1f,
0x02,0x1f,0x02,0x1f,0x02,0x1f,0x02,0x1f,
0x6b,0x7f,0x3e,0x0d,0x0f,0xb1,0xb8,0xbc, /* 288 */
0x0f,0xeb,0x9b,0xaa,0xd0,0x1c,0xe1,0x10, 
0x9c,0x00,0x4c,0xc2,0x90,0x4a,0x8d,0x3c,
0xf9,0x7e,0xa2,0x38,0x58,0x8d,0x28,0xe1,
0xea,0x67,0xf0,0x8b,0x85,0x9b,0x58,0xbf, /* 320 */
0x9e,0xf8,0xfc,0xaf,0x52,0xb0,0xae,0x8f,
0xa8,0xbd,0x07,0x8c,0x37,0xa1,0x40,0x7b,
0xa7,0xfc,0x83,0xf0,0xac,0x0b,0xed,0x2a,
0x73,0x8b,0x65,0x04,0xbf,0xcb,0xfd,0xc8, /* 356 */
0x54,0xaa,0x67,0xbe,0x51,0xbc,0x97,0x89,
0xbf,0x5b,0xb8,0x07,0xff,0xc4,0xa6,0x5a,
0x6b,0x33,0x6f,0x8a,0x22,0xfe,0xfd,0x93

};


int testAP(unsigned char *data, int len, int cont)
{
  int rv = 0;
  int i = 0;


    for(i = 0; (0 == rv) && (i < (len-512)) ; i++) {
      if( 0 != APtestBK(50,data+i) ) {
	      rv = 1;
	      break;
      }


  }
  return rv;
}
int testRC(unsigned char *data, int len)
{
  int rv = 0;

  if( 0 != RCtestBK(50,data) ) {
	  rv = 1;
  }

  return rv;
}
/*! @brief test the Adaptive Proportion health test
  @return 0 if O.K. !0 on failure. Bit one is set on 
  a false negative, bit 2 if it fails to detect a condition
  that should have resulted in a fail.
  \known Inplementation: Self test of the Adapative Proportion test
*/

int APTests() {
  int rv = 0;
  if( 0 != testAP(good50,sizeof(good50),0) ) {
    rv |= 1;
  }

  if( 0 == testAP(failAP50,sizeof(failAP50),0) ) {
    rv |= 2;
  }
  
  /*! \induced 240. Force a failure of AP self test */
  if(240 == icc_failure) {
    rv |= 1;
  }
  
  return rv;
}
/*! @brief test the Repeat Count health test
  @return 0 if O.K. !0 on failure. Bit one is set on 
  a false negative, bit 2 if it fails to detect a condition
  that should have resulted in a fail.
  \known Implementation: Self test of the Repeat Count algorithm
*/
int RCTests()
{
  int rv = 0;
  if( 0 != testRC(good50,sizeof(good50))) { 
    rv |= 2;
  }
  if( 0 == testRC(failRC50,sizeof(failRC50))) { 
    rv |= 1;
  }
  /*! \induced 242. Force a failure of RC self test */
  if(242 == icc_failure) {
    rv |= 1;
  }
  return rv;
}
/*!
  @brief check that the pmax algorithm returns the results we
  say it should. This is a self test to confirm that the algorithm
  is operating as it was designed to operate, accuracy is assessed offline.
  @return 0 if O.K. !0 is we got an unexpected result
  @note we expect to underestimate entropy.
  @note some of this test (accuracy compared with
  floating point) is only run in offline mode as we have library dependency 
  issues
  @note These tests operate by comparing the points at which assessed
  entropy changes when compared with a reference version. The reference
  version was compiled with the floating point variant enabled so we can
  check accuracy. On Linux:
  gcc nist_algs.c -I ../ -D STANDALONE -D TEST_DOUBLE -lm -o nist_algs
  \known Implementation: Self test of the pmax algorithm
*/

int pmax4Tests()
{
  /* The implementation is relatively simple, we start with an array
     filled with well distributed data, then cripple the data and track 
     the entropy decay. Passing is considered getting the same answers
     as the reference code on the same data set
  */


  int rv = 0;
  /* This is pairs of [change point, new values from pmax] 
     when run against badE (above)
   */
  static unsigned int trans[] = {35,50,45,75,46,50,54,75,61,50,65,75,73,50,74,75,75,50,97,25,108,0,160,25,227,50,247,75,251,50,252,75,258,50,279,75,282,50,284,75,287,50,288,75,290,50,292,75,297,50};
  int i = 0; 
  int k = 0;
  int e = 0;
  int laste = -1;



  
  for(i = 0; i < (sizeof(good50)-32); i++) {
    e = pmax4(good50+i,32);
    if( e != laste) {
      laste = e;
    }
    if(e < 50) {
        rv |= 1;
        printf("good50 not so good i = %d, e = %d\n",i,e);
    }
  } 


 

  for(i = 0; i < (sizeof(badE)-32) && k < (sizeof(trans)-1); i++) {
    e = pmax4(badE+i,32);
    if( e != laste) {
      if( (trans[k] != i) || trans[k+1] != e) {
        printf("i = %d e = %d\n",i,e);
	      rv |= 2;
        
      }
      k+= 2;     
      laste = e;
    }
  }
  /*! \induced 244. Force a failure of pmax self test */
  if(244 == icc_failure) {
    rv |= 1;
  }
  return rv;
}
/*
  This is test code so we can see the numbers coming up sane.

  Note, we can never have a bucket with <8 samples come up as the most frequent value.
  We have 128 samples spread across 16 buckets and <8 samples in one bucket means
  there has to be at least 1 more sample somewhere else.

  Uniformly distributed would have 8 samples/bucket (max entropy)
  very poorly distributed would have all 128 samples in one bucket
  The odds of a perfect distribution are really poor but it can happen
  so we have 5 entropy values (e)
  4 = e = 100% 
  3 = 75% <= e < 100%
  2 = 50% <= e < 75%
  1 = 25% <= e < 50%
  0 = 0%  <= e < 25%


  The original code had a bug and missed the 100% case.
  */
void testiLog2()
{ 
  unsigned int i = 0;
  static const int etab[5] = {0,25,50,75,100};
  printf("x = ilog2(i) i (8:68)\n");
  for(i = 8; i < 68; i++) {
    printf("%03d ",i);
  }
  printf("\n");
  for(i = 8; i < 68; i++) {
    printf("%03d ",ilog2((64*2)/i));
  }
  printf("\n");
  for(i = 8; i < 68; i++) {
    printf("%03d ",etab[ilog2((64*2)/i)]);
  }

  printf("\nx = ilog2(i) i (61:128)\n");
  for(i = 69; i <= 128; i++) {
    printf("%03d ",i);
  }
  printf("\n");
  for(i = 69; i <= 128; i++) {
    printf("%03d ",ilog2((64*2)/i));
  }
  printf("\n");
  for(i = 69; i <= 128; i++) {
    printf("%03d ",etab[ilog2((64*2)/i)]);
  }

  printf("\n");
}

#if defined(STANDALONE)
unsigned int icc_failure = 0;

int main(int argc, char *argv[])
{
#if 0
  /* Debug the counts in bucket to entropy code */
  testiLog2();
  return 1;
#endif  
  if(0 != pmax4Tests()) {
    printf("pmaxTest Failed when should have passed\n");
  }
  if( 0 != testAP(good50,sizeof(good50),1) ) {
    printf("AP Failed when should have passed (good/64/0)\n");
  }
   if( 0 == testAP(failAP50,sizeof(failAP50),0) ) {
    printf("AP Passed when should have failed (failAP/1)\n");
  }
 
  if( 0 != testRC(good50,sizeof(good50))) { 
    printf("RC Failed when should have passed (good)\n");
  }
  if( 0 == testRC(failRC50,sizeof(failRC50))) { 
    printf("RC Passed when should have failed (failRC)\n");
  }

  return 0;
}

#endif

